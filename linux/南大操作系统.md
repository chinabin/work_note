# 0x00. 导读

# 0x01. 简介

# 0x02. 

程序就是状态机。源代码的程序是状态机，二进制的程序是状态机，两者通过编译器连接。

程序=计算指令-> syscall -> 计算指令-> syscall -> ...  
计算好自己的状态，算出一系列参数，然后告诉操作系统，帮我去完成某个功能。

状态机的两个视角，状态机是等价的

# 0x03. 

[Linux 内核的操作系统是不是得一直运行着？](https://www.zhihu.com/question/23561375/answer/25345790)

当年上我老板的OS课，老板上来就告诉我们，OS不是运行着的代码，而是一堆躺在内存里等着被调用的代码。内核就是一个由interrupt驱动的程序。这个interrupt可以是一个系统调用（x86下，很多OS的系统调用是靠software interrupt实现的），可以是一个用户程序产生的异常，也可以是一个硬件产生的事件中断。于是你的问题解决了：一个用户程序运行的时候，Linux就在内存里呆着，等着一个中断的到来。在这个中断的处理过程中，来做“调度”。而一般的时分系统里，都会有个timer interrupt每隔一段时间到来，也就是楼上说的“时间片”。PS：很多人在认识OS的过程中被大量的artificial concept给困惑了。比如神马进程，线程，调度，micro kernel，monolithic kernel的。从x86架构上来理解OS才是王道。

进程，线程，系统调用这样的东西都是由os在硬件上抽象出来的。站在这些概念上看os，就有点“不识庐山真面目”的感觉。  
所以我的意思是从硬件的角度看os，反过来理解为何os要抽象出这些概念。站在cpu的角度，理解指令是怎么在cpu上一条一条的运行的。