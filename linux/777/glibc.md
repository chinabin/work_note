# 0x00. 导读

# 0x01. 简介

[官网](https://sourceware.org/glibc/)

GNU C Library, 又名 glibc, glibc 是 GNU 发布的 libc 库，即 c运行库。

OS 完全自包含并且对外服务，那么应用程序怎么使用 OS 提供的服务？通过系统调用。所谓系统调用，其实要么是中断指令，要么是特权指令，然后在堆栈处存放调用号和参数，OS 就知道应用程序想要什么服务。系统调用实际上是切换了 CPU 的运行环境，这种环境的切换由 CPU 负责，包括权限的限制等等。这种方式有点像大家经常碰到的服务窗口，你将服务单号递进窗口，里面接单后进行处理，过一段时间，处理完后，将结果从窗口递还给你。如果每个应用程序都自己写使用系统调用的代码，那大家都累且不规范，于是有人将所有的系统调用都封装好，做成好用的调用接口，这就是 **C运行库**，简称 C库。 glibc 是 C库 的一种实现。有多种 C库 的实现，glibc 只是其中一种，不过是一个应用范围最广，使用人数最多的一种实现。

C库 里的系统调用是如何准确调用的？这事情解决很简单，由编译脚本来完成目标系统的识别。编译脚本判断完目标系统系统以后，比如 X86+LINUX，它会寻找 OS 对外暴露的系统调用头文件，比如 `/usr/include/linux`，在头文件里，大家约定好 C库 如何调用本 OS 的系统调用的格式和指令，然后编译脚本通过代码模板将这些系统调用封装好，基本上就是用宏将汇编指令封装成最低层的C函数，然后稍微上层一点的C函数，比如 read/write 函数早就适配好要调用哪些封装C函数。这些都是编译脚本自动生成，然后就可以编译了。如果将 glibc 移植到一个新的平台，只要按照规则将一些脚本和模板编写好，后面都是由编译脚本自动完成。这种约定已经很成熟了，基本上不需要我们操心。

GNU 社区比 Linux 内核要早，GNU 社区是开源软件的最大推动者。后来有了 Linux 以后， GNU 开始支持 Linux ，但并不是同步的。 Linux 内核的初始版本并没有 glibc 的支持。 GNU 社区在寻找一个合适的操作系统，Linux 在寻找一个合适的 C 库，然后这俩拨人一看，都是开源/免费软件，一拍即合，这俩才就走到了一起。

注意这俩并不是完全绑定的，glibc 可以用在 freeBSD 上， Linux 上也可以用 musl 作为 C 库。只不过现在制作 Linux 发行版的企业，都默认使用 Linux+glibc 的方案而已。

# 0x02.

glibc 的库文件在 `/usr/lib` 目录下，glibc 的头文件在 `/usr/include` 目录下。

版本查看:
```bash
$ /lib64/libc.so.6

$ ldd --version
```