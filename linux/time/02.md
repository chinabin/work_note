# 0x00. 导读

《Linux 内核设计与实现第三版》，基于 Linux 2.6.34 ，第 11 章，定时器和时间管理

本文脉络：

1. 三个需求

    - 周期性执行的事件，例如 一秒钟刷新一次界面
    - 延迟执行的事件，例如 三秒钟之后看看是否收到消息
    - 知道当前的时间和日期

2. 实现需求

    - 问题一、三  
        系统定时器，它会以固定频率（ HZ ）产生中断，会有中断处理程序来处理中断。  
        （需要知道 HZ 、jiffies ，中断处理程序的逻辑（重点）。系统定时器种类有 PIT 、本地 APIC 、TSC 。）

    - 问题二  
        动态定时器，设定未来某个时间点提醒我  
        （需要了解定时器 api 的使用流程，需要知道延迟执行的三种方式，了解就好）

# 0x01. 简介

相对于事件驱动而言，内核中有大量的函数都是基于时间驱动的。其中有些函数是周期执行的，例如对调度程序的运行队列进行平衡调整，需要定期实行，比如说，一秒钟执行 100 次。而另外一些函数，则需要等待一个相对时间后才运行，比如说，内核会在 50ms 后执行某个任务。除了上述两种函数需要内核提供时间外，内核还必须管理系统的运行时间以及当前日期和时间。

周期性产生的事件——比如每 10ms 一次，都是由系统定时器驱动的。**系统定时器**是一种可编程硬件芯片，它能以固定频率产生中断。该中断就是所谓的定时器中断，它所对应的中断处理程序负责更新系统时间，也负责执行需要周期性执行的任务。系统定时器和时钟中断处理程序是 Linux 系统内核管理机制中的中枢。

动态定时器是一种用来推迟执行程序的工具。比如说，如果软驱动马达在一定时间内都未活动，那么软盘驱动程序会使用动态定时器关闭软驱动马达。内核可以动态创建或撤销动态定时器。

# 0x02. 系统定时器

硬件为内核提供了一个系统定时器用以计算流逝的时间，系统定时器以某种频率自行触发时钟中断，当时钟中断发生时，内核就通过一种特殊的中断处理程序对其进行处理。内核就是靠时钟中断间隔时间来计算 wall time 和系统运行时间的。内核为用户空间提供了一组系统调用用来获取日期和时间。

对于时钟中断依赖的任务：
- 更新系统运行时间
- 更新实际时间
- 调度程序
- 运行超时的动态定时器
- 更新资源消耗和处理器时间的统计值

体系结构中提供了两种设备进行计时，一种是前面提到的 **系统定时器** ，另一种是 实时时钟( RTC ) 。

RTC 是用来持久存放系统时间的设备，及时系统关闭，也可以靠主板上的电池继续计时。当系统启动的时候，内核通过读取 RTC 来初始化 wall time ，该时间存放在 xtime 变量中。虽然内核通常不会在系统启动后再读取 xtime 变量，但是有些体系结构会周期性的将当前时间值写回 RTC 中，尽管如此，**RTC 最主要的作用仍是在启动时初始化 xtime 变量**。

系统定时器是内核定时机制中最为重要的角色，尽管不同体系结构中的定时器实现不一样，但是系统定时器的根本思想并没有区别：**提供一种周期性触发中断机制**。在 x86 体系结构中，主要采用 **可编程中断时钟(PIT)** 。PIT 在 PC 机器中普遍存在，而且从 DOS 时代，就开始用它作为时钟中断源了。内核在启动时对 PIT 进行编程初始化，使其能够以 HZ/秒 的频率产生时钟中断。x86 体系结构中其它的时钟资源还包括 本地APIC 和 时间戳计数(TSC) 等。

## 2.1 HZ

节拍率 HZ 是通过静态预处理定义的，在系统启动时按照 HZ 值对硬件进行设置，一般可选值是 100 250 1000 。

Linux 内核支持 tickless 选项，在编译内核时设置 CONFIG_HZ 配置选项，系统就根据这个选项动态调度时钟中断，也就是说，不再是每隔固定的时间间隔触发时钟中断，而是按需动态调度和设置。例如设置下一个时钟频率为 3ms ，就每 3ms 触发一次时钟中断，之后如果 50ms 内都无事可做，内核以 50ms 重新调度时钟中断。

在 2.6 版以前的内核中，如果改变内核中 HZ 的值，会给用户空间中的程序造成异常的结果，因为用户空间并不知道新的 HZ 值。所以内核定义了 USER_HZ 来代表用户空间看到的 HZ 值，并且提供 jiffies_to_clock_t() 来获取正确的 节拍数/秒 的值。

## 2.2 jiffies

全局变量 jiffies 用来记录自系统启动以来产生的节拍总数，一秒内时钟中断的次数是 HZ ，所以一秒内 jiffies 增加的值也就是 HZ ，系统运行时间以秒为单位，就等于 jiffies/HZ 。


## 2.3 时钟中断处理程序

时钟中断处理程序分为 体系结构相关部分 和 体系结构无关部分。

体系结构相关部分最少要完成如下工作：

- 获得 xtime_lock 锁，以便对访问 jiffies_64 和墙上时间 xtime 进行保护。
- 需要时应答或重新设置系统时钟。
- 周期性地使用墙上时间更新实时时钟。
- 调用体系结构无关的时钟例程：tick_periodic()。

中断服务程序主要通过调用与体系结构无关的例程， tick_periodic() 执行更多的工作：

- 给 jiffies_64 变量增加 1。
- 更新资源消耗的统计值，比如当前进程所消耗的系统时间和用户时间。
- 执行已经到期的动态定时器。
- 执行 scheduler_tick 函数。
- 更新墙上时间，该时间存放在 xtime 变量中。
- 计算平均负载值。

因为上述工作分别都由单独的函数负责完成，所以 tick_periodic() 例程的代码看起来非常简单。
```c
static void tick_periodic(int cpu)
{
	if (tick_do_timer_cpu == cpu) {
		write_seqlock(&xtime_lock);
 
		/* 记录下一个节拍事件 */
		tick_next_period = ktime_add(tick_next_period, tick_period);
 
		do_timer(1);
		write_sequnlock(&xtime_lock);
	}
 
	update_process_times(user_mode(get_irq_regs()));
	profile_tick(CPU_PROFILING);
}
```

很多重要的操作都在 do_timer() 和 update_process_times() 函数中进行。

```c
void do_timer(unsigned long ticks)
{
	jiffies_64 += ticks;
	update_wall_time();     // update wall time
	calc_global_load();     // 更新系统平均负载统计值
}
```

```c
void update_process_times(int user_tick)
{
	struct task_struct *p = current;
	int cpu = smp_processor_id();
 
	/* 注意：也必须对这个时钟irq的上下文说明一下原因 */
	account_process_tick(p, user_tick);
	run_local_timers();
	rcu_check_callbacks(cpu, user_tick);
	printk_tick();
	perf_event_do_pending();
	scheduler_tick();
	run_posix_cpu_timers(p);
}
```

以上全部工作每 1/HZ 秒都有发生一次，也就是说在 x86 机器上时钟中断处理程序每秒执行 100 次或者 1000 次。

## 2.4 wall time

当前实际时间 (墙上时间) 定义在文件 (kernel\time\timekeeping.c) 中：

`struct timespec xtime;`

```c
struct timespec {
	__kernel_time_t	tv_sec;		/* 秒 */
	long		tv_nsec;		/* 纳秒 */
};
```

xtime.tv_sec 以秒为单位，存放着自 1970 年 1 月 1 日以来经过的时间，xtime.tv_nsec 记录自上一秒开始经过的 ns 数。

读写 xtime 变量需要使用 xtime_lock 锁，该锁不是普通的自旋锁而是一个 seqlock 锁。

从用户空间取得墙上时间的主要接口是 gettimeofday()，在内核中对应系统调用 sys_gettimeofday()

# 0x03. 定时器

定时器 (有时也称为 **动态定时器** 或 **内核定时器**) 是管理内核流逝的时间的基础。内核经常需要推后执行某些代码，比如下半部机制就是为了将工作放到以后执行。但不幸的是， **之后** 这个概念很含糊，下半部的本意并非是放到以后的某个时间去执行任务，而仅仅是不在当期执行就可以了。我们需要的是一种工具，能够使工作在指定时间点上执行。内核定时器正是解决这个问题的理想工具。

定时器的使用很简单。你只需要执行一些初始化工作，设置一个超时时间，指定超时发生后执行的函数，然后激活定时器就可以了。指定的函数将在定时器到期时自动执行。注意定时器并不周期执行，它在超时后就自行撤销，这也正是这种定时器被称为动态定时器的一个原因；动态定时器不断地创建和撤销，而且它的运行次数也不受限制。定时器在内核中应用得非常普遍。

定时器由结构 `timer_list` 表示，定义在文件 `<linux/timer.h>` 中

```c
struct timer_list {
	struct list_head entry;				/* 定时器链表入口 */
	unsigned long expires;				/* 以jiffies为单位的定时值 */
	void (*function)(unsigned long);	/* 定时器处理函数 */
	unsigned long data;					/* 传给处理函数的长整型参数 */
	struct tvec_base *base;				/* 定时器内部值，用户不要用 */
};
```

```c
// 1. 声明变量
struct timer_list my_timer;
// 2. 初始化
init_timer(&my_timer);
// 33 填充
my_timer.expires = jiffies + delay;		/* 定时器超时时的节拍数 */
my_timer.data = 0;						/* 给定时器处理函数传入0值 */
my_timer.function = my_function;		/* 定时器超时时调用的函数 */
/*

my_timer.expires 表示超时时间，它是以节拍为单位的绝对计数值。如果当前 jiffies 计数等于或大于 my_timer.expires，那么 my_timer.function 指向的处理函数就会开始执行，另外该函数还要使用长整型参数 my_timer.data。所以正如我们从 timer_list 结构看到的形式，处理函数必须符合下面的函数原型：

void my_function(unsigned long data);

data 参数使你可以利用同一个处理函数注册多个定时器，只需要通过该参数就能区别对待它们。如果你不需要这个参数，就可以简单地传递 0(或任何其他值) 给处理函数。

*/

// 4. 激活定时器：
add_timer(&my_timer);

// 大功告成，定时器可以工作了！但请注意定时值的重要性。当前节拍计数等于或大于指定超时时，内核就开始执行定时器处理函数。虽然内核可以保证不会在超时时间到期前运行定时器处理函数，但是有可能延误定时器的执行。一般来说，定时器都在超时后马上就会执行，但是也有可能推迟到下一次时钟节拍时才能运行，所以不能用定时器来实现任何硬实时任务。

```
有时可能需要更改已经激活的定时器超时时间，所以内核通过函数 mod_timer() 来实现该功能，该函数可以改变指定的定时器超时时间：

```c
mod_timer(&my_timer,jiffies+new_delay);		/* 新定时值 */
```

如果需要定时器超时前停止定时器，可以使用 del_timer() 函数：

```c
del_timer(&my_timer);
```

被激活或未被激活的定时器都可以使用该函数，如果定时器还未被激活，该函数返回 0；否则返回 1。注意，不需要为已经超时的定时器调用该函数，因为它们会自动删除。

当删除定时器时，必须注意一个潜在的竞争条件。当 del_timer() 返回后，可以保证的是：定时器不会再被激活，但是在多处理器机器上定时器中断可能已经在其他处理器上运行了，所以删除定时器时需要等待可能在其他处理器上运行的定时器处理程序都退出，这时就要使用 del_timer_sync() 函数执行删除操作：

```c
del_timer_sync(&my_timer);
```
和 del_timer() 函数不同，del_timer_sync() 函数不能在中断上下文中使用。一般情况下应该使用 del_timer_sync() 函数取代 del_timer() 函数，因为无法确定在删除定时器时，它是否正在其他处理器上运行。为了防止这种情况的发生，应该调用 del_timer_sync() 函数，而不是 del_timer() 函数。否则，对定时器执行删除操作后，代码会继续执行，但它有可能去操作在其他处理器上运行的定时器正在使用的资源，因而造成并发访问，所以请优先使用删除定时器的同步方法。

## 3.1 延迟执行

内核代码 (尤其是驱动程序) 除了使用定时器或下半部机制以外，还需要其他方法来推迟执行任务。

- 忙等待

    最简单的延迟方法 (虽然通常也是最不理想的办法) 是忙等待。但要注意该方法仅仅在想要延迟的时间是节拍的整数倍，或者精确率要求不高时才可以使用。  
    忙循环实现起来很简单——在循环中不断旋转直到希望的时钟节拍数耗尽，比如：

    ```c
    unsigned long timeout = jiffies + 10;	/* 10个节拍 */
    while(time_before(jiffies,timeout));
    ```

- 短延迟

    有时内核代码 (通常也是驱动程序) 不但需要很短暂的延迟(比时钟节拍还短)，而且还要求延迟的时间很精确。这种情况多发生在和硬件同步时，也就是说需要短暂的等待某个动作的完成(等待时间往往小于 1ms)，所以不可能使用像前面例子中哪种基于 jiffies 的延迟方法。对于频率为 100HZ 的时钟中断，它的节拍间隔甚至会超过 10ms！即使频率为 1000HZ 的时钟中断，节拍间隔也只能到 1ms，所以我们必须寻找其他方法满足更短、更精确的延迟要求。

    幸运的是，内核提供了三个可以处理 us、ns 和 ms 级别的延迟函数，它们定义在文件 <linux/delay.h> 和 < asm/delay.h > 中，可以看到它们并不使用 jiffies：

    ```c
    void udelay(unsigned long usecs);
    void ndelay(unsigned long nsecs);
    void mdelay(unsigned long msecs);
    ```

- schedule_timeout

    更理想的延迟方法是使用 schedule_timeout() 函数，该方法会让需要延迟执行的任务睡眠到指定的延迟时间耗尽后再重新运行。但该方法也不能保证睡眠时间正好等于指定的延迟时间，只能尽量使睡眠时间接近指定的延迟时间。当指定的时间到期后，内核唤醒被延迟的任务并将其重新返回运行队列，用法如下：

    ```c
    /* 将任务设置为可中断睡眠状态 */
    set_current_state(TASK_INTERRUPTIBLE);
    /* 小睡一会儿，"s"秒后唤醒 */
    schedule_timeout(s*HZ);
    ```