# 0x00. 导读

# 0x01. 简介

杂文故事

# 0x02. 故事

nohz 标志着 linux 开始成熟起来。

nohz 为何这么重要呢？因为它直接关系到了性能，直接联系着系统的心跳，以前，系统总是被动的接受时钟中断，然后运行中断处理程序，最终可能导致调度的发生，如果实在没有任务可以运行，那么就执行 idle, 可是时钟中断还是会周期性的打破 idle，然后查询有没有需要做的事情，如果没有继续 idle。

可是我们总是希望系统可以主动的做些事情，比如不是被动的接受中断而是主动的设置什么时候中断，因此必须将系统时钟发生中断这件事进行向上抽象，于是相应的 `clocksource` 和 `clock_event_device` 这两个结构体就是时钟以及时钟行为的抽象：
- clocksource 代表了一个时钟源，一般都会有一个计数器，其中 的 read 回调函数就是负责读出其计数器的值。 clocksource 就是一个钟表，我们需要一个钟表就是需要读出它的指针的值从而知道现在几点，钟表就是用来读数的。
- clockevent 是闹钟，不要因为有闹钟的存在就说闹铃都有钟表，它们其实是两个东西，钟表为你展示某些事情，而闹铃需要你的设置。设想一个场景，你手边有一个没有闹铃的钟表，还有一个没有 钟表的闹铃，这个闹铃只能设置绝对时间，然后到期振铃，你现在不知道几点，可是你要睡觉并且得到通知必须在四个小时后去参加一个聚会，那么你现在要做什么？你肯定要看看你的钟表，然后设置你的闹钟。

2.6.18 之前的内核中没有抽象出“钟表” 和“闹铃”的逻辑，默认内核一直有事可做，软件是硬件的奴隶，不得不在硬件的默认前提下每隔一个时间段就被中断一次，而硬件只管定时中断而不管到底是否真正有事可做，理想的实现应该是将定时的任务交给内核自己。

clocksource 和 clock_event_device 被抽象出来以后，clock_event_device 中有了定闹铃的把手，一切就醒目多了，实际上 clocksource 和 clock_event_device 被抽象出来并不是为了 nohz，而是为了将时钟相关的代码从平台相关的代码中分离出来，以便于独立修改统一管理，否则需要维护很多平台的不同的时钟处理代码，而这些代码的逻辑大致相同，随后的 2.6.22 以后，nohz 才出现，nohz 其实就是托了抽象出来的 clocksource 和 clock_event_device 的福，因为 nohz 直接需要设置下一次的中断时间而不是使用系统无条件的默认的 HZ 中断。 clock_event_device 中的 set_next_event 就是定闹铃的把手，而 event_handler 则是可以让你自己定义闹铃到期后的事件，就好比手机定闹铃时可以选到期后播放的音乐一样可以自定义事件处理回调函数。

clocksource 是一个钟表，clock_event_device 是一个闹铃，它们可以合并为一个闹钟，也可以单独行动，既然 clock_event_device 是一个闹钟而且必然拥有定闹铃的把手（set_next_event），那么时钟中断就是由这个 clock_event_device 来设置的了，设置的中断到来以后，还是这个 clock_event_device 负责用 event_handler 来唱一支歌，毕竟它是闹铃，闹铃要负责在到期后响铃的，而且除了响铃也可以做别的，而 clocksource 只是一个可以从中得到一个读数的一个源头罢 了。