# 0x00. 导读

IO 调度。

# 0x01. 简介

由于现在的机械硬盘设备的寻道是非常慢的（常常是毫秒级），因此尽可能的减少寻道操作是提高性能的关键所在。一般 I/O 调度器要做的事情就是在完成现有请求的前提下，让磁头尽可能少移动，从而提高磁盘的读写效率。最有名的就是 “电梯算法” 了。

由于 I/O 调度器的存在，kernel 并不会按实际收到的顺序将请求发到底层设备上，而是经过了合并（减少请求数量和寻道，如果无法合并将请求放在队列尾部）和排序处理（类似电梯的减少往返寻道的处理，也是 I/O 调度器被称为 elevators 的原因）。**I/O 调度器就是来管理块设备的请求队列的，它来决定队列中请求的顺序，以及每个请求什么时候到派遣到块设备上。**

# 0x02. 调度器

现在的 Linux kernel 中已经有几种好用的 I/O 调度器，常见的包括 Linus（2.4 版本中的调度器）、cfq（很多发行版中的默认调度器）、deadline、noop、anticipatory（相对 deadline 的优化） 等。

Linus 调度器同时实现了合并和排序处理，而且是 front merging （新请求在当前的前面） 和 back merging （新请求在当前的后面，当然比 front merging 常见） 都支持的，并且有一定的请求时限处理。

deadline 调度器主要解决 Linus 调度器导致的请求饥饿问题（不能及时有效的被处理），deadline 调度器保证请求的开始服务时间。另外 deadline 解决了写请求（一般为异步处理）使读请求（一般为同步处理）不能被及时处理的问题，也就是解决读延迟。

noop 调度器几乎保持原始请求顺序不变（仍然有合并）。

cfq 则提供类似完全公平的调度策略。

总之不同的 I/O 调度器通常是对于特定类型的请求进行优化的。

I/O 调度的一些数据结构声明在 `<linux/elevator.h>` 头文件中，比较重要的包括 elevator_ops、elevator_type 以及 elevator_queue 等。elevator_ops 中定义了 I/O 调度算法的各种操作函数接口。
