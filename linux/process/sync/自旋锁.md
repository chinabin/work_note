# 0x00. 导读



# 0x01. 简介

自旋锁的概念很简单，如果加锁失败了，在等锁时使用忙等待。  
自旋锁的逻辑是，用自旋锁保护的临界区要足够小，当自旋锁加锁失败时，说明有其它的临界区正在执行中。由于自旋锁的临界区足够小且不会休眠，所以我们可以自旋忙等待其它临界区的退出，没必要去休眠，因为休眠要做一大堆操作。而忙等待的话，对方很快就会退出临界区，我们就可以很快地获得自旋锁了。

# 0x02. 前提补充

先说结论： spinlock 会关闭本 CPU 中断，会禁止本 CPU 上的调度，临界区内不能休眠的。

## 2.1 单处理器上临界区问题

对于单处理器来说，由于任何一个时刻只会有一个执行单元，因此不存在多个执行单元同时访问临界区的情况。但是依然存在下面的情形需要保护：

- Case 1 任务上下文抢占

    低优先级任务A进入临界区，但此时发生了调度(比如发生了中断, 然后从中断中返回),高优先级任务B开始运行访问临界区。  

    解决方案：进入临界区前**禁止抢占**就好了。这样即使发生了中断，中断返回也只能回到任务A.

- Case 2 中断上下文抢占

    任务A进入临界区，此时发生了中断，中断处理函数中也去访问修改临界区。当中断处理结束时，返回任务A的上下文，但此时临界区已经变了！

    解决方案：进入临界区前**禁止中断**(顺便说一句，这样也顺便禁止了抢占)

## 2.2 中断、调度、睡眠

睡眠依赖调度器唤醒，调度器通过时钟中断判断何时唤醒任务。

所以，关了中断，调度器再也无法收到时钟中断了，所以就无法唤醒任务了。调度器无法工作，也就等于关了调度（**关中断就是关调度**）。所以操作系统中，关中断时不能睡眠，睡眠就会睡死了。

spinlock 肯定会关调度，别人别和我抢这个临界区，同时也不让其它核抢。 同时，spinlock 分为两种，一种是顺带关中断的，另一种不是。对于第一种，是我们经常遇见的，没中断就没调度。对于第二种，这种情况下理论上是可以产生调度的，但又因为关了抢占，别的任务又不能跑，这个核实际上是浪费了。

## 2.3 多处理器上临界区问题

- case 1 其他CPU访问

    任务A运行在CPU_a上，进入临界区前关闭了中断(本地)，而此时运行在CPU_b上的任务B还是可以进入临界区！没有人能限制它

    解决方案：任务A进入临界区前持有一个互斥结构，阻止其他CPU上的任务进入临界区，直到任务A退出临界区，释放互斥结构。

    这个互斥结构就是自旋锁的来历。所以本质上，自旋锁就是为了针对SMP体系下的同时访问临界区而发明的！


# 0x03. 说回 spinlock

由于 spin_lock 会关闭抢占，所以天然解决伪并发的问题。


[获取自旋锁和禁止中断的时候为什么不能睡眠?](https://www.zhihu.com/question/28821201/answer/42214222)  
[深入理解同步机制---内核自旋锁](https://switch-router.gitee.io/blog/spinlock/)