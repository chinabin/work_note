# 0x00. 导读

[深入 Linux 的进程优先级](https://linux.cn/article-7325-1.html)  

# 0x01. 简介

![Alt text](../../pic/linux/sched/nice_priority.png)

进程的优先级该如何确定？有两种方式：由用户程序指定、由内核的调度程序动态调整。

# 0x02. 用户空间角度

从用户空间来看，进程优先级就是 nice value 和 scheduling priority.

```c
#define MAX_NICE 19
#define MIN_NICE -20
#define NICE_WIDTH (MAX_NICE - MIN_NICE + 1)
// 100 + 40 / 2 = 120 
// 实际上对应的就是 nice 值的 0
#define DEFAULT_PRIO            (MAX_RT_PRIO + NICE_WIDTH / 2)
```

```c
#define NICE_TO_PRIO(nice)  (MAX_RT_PRIO + (nice) + 20)
#define PRIO_TO_NICE(prio)  ((prio) - MAX_RT_PRIO - 20)
#define TASK_NICE(p)        PRIO_TO_NICE((p)->static_prio)

// MAX_RT_PRIO = 100
```

## 2.1 nice 值

`nice 值`，取值范围为 -20~19，默认为 0 。这个值越小，表示进程”优先级”越高，而值越大“优先级”越低。当 nice 值设定好了之后，除非我们用 renice 去改它，否则它是不变的。

对于普通进程而言，进程优先级就是 nice value.

## 2.2 scheduling priority

随着实时需求的提出，进程又被赋予了另外一种属性 scheduling priority ，这些进程就是实时进程。
实时进程的 scheduling priority 的范围是 1（优先级最低）～99（优先级最高） 。当然，普通进程也有 scheduling priority ，被设定为 0。

# 0x03. 内核空间角度

task struct数据结构中有4个成员，用来描述进程的优先级。
```c
struct task_struct {
    int prio;
    int static_prio;
    int normal_prio;
    unsignea int rt_priority;
};
```
- `staticprio`

    1. 静态优先级，用于普通进程。 120 + nice ，范围是 100 ~ 139 ，缺省值是 120 ，值越小，优先级越高

- `rt_priority`

    1. 实时优先级，也就是从用户空间的视角来看的 scheduling priority 。范围是 1 ~ 99, 数字越大优先级越高， 0 表示该进程是普通进程。

- `normalprio`

    1. 归一化优先级，根据静态优先级、 scheduling priority 和调度策略来计算得到。何为归一，如果我们使用了不同的方式来刻画同一个概念，那么势必会带来管理上的麻烦，所谓归一化，就是设计一种转换方式，将这些不同的方法统一到同一种方法上去，从而简化问题的模型。
    2. 范围是 -1 ~ 139 ，并且数字越小优先级越大。
    3. -1 是 deadline 进程的优先级。对于普通进程来说，normal_prio 等同于 static_prio ；对于实时进程，会根据 rt_priority 重新计算 normal_prio = 99 - rt_priority, 最高 0 ，最低 99.

    ```c
    static inline int normal_prio(struct task_struct *p)
    {
        int prio;

        if (task_has_dl_policy(p))
            prio = MAX_DL_PRIO-1;
        else if (task_has_rt_policy(p))
            prio = MAX_RT_PRIO-1 - p->rt_priority;
        else
            prio = __normal_prio(p);
        return prio;
    }
    ```

- `prio`

    保存着进程的动态优先级，也是调度类使用的优先级。