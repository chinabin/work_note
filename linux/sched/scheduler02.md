# 0x00. 导读

介绍 O（n）调度器。

# 0x01. 简介

[O（n）调度器](https://en.wikipedia.org/wiki/O(n)_scheduler) 是 Linux 2.4 至 2.6 版本使用。其实现思路非常简单。

O(n) 调度器 采用一个全局的运行队列来管理任务，该队列的表头保存在全局变量 `runqueue_head` 中。所有的就绪任务都会被放入该队列中，每次调度时，系统会遍历整个队列然后挑出最适合的任务，即优先级最高的任务来执行，因此该调度算法的时间复杂度为 O(n), 这也是该调度器被叫着 O(n)调度器 的原因。

# 0x02. 调度逻辑

调度器通过一次遍历选取了优先级最高的任务，如果队列为空，则系统将在该 CPU 上运行 idle task 。

注意在该版本中，调度器仅支持 **实时任务与普通任务**，实时进程的调度策略包含 SCHED_FIFO 与 SCHED_RR, 普通进程的调度策略叫 SCHED_NORMAL, 相当于现在的 SCHED_NORMAL, 实时进程的优先级高于普通进程，需要优先保证其时间供给。

`struct task_struct` 中与优先级计算有关的字段包含如下几个：
```c
/* file: include/linux/sched.h */

struct task_struct {
    /* 任务当前剩余的运行时间，以时钟嘀嗒（tick）为单位 */
    long counter;
    /* 普通任务的优先级，即用户设置的进程 nice 值 */
    long nice;
    /* 任务的调度策略 */
    unsigned long policy;
    /* 任务的内存地址空间，由同一个进程的不同线程共享 */
    struct mm_struct *mm;
    /* 实时任务的优先级 */
    unsigned long rt_priority;
}
```

我们将 nice 与 rt_priority 叫着 **静态优先级**，因为他们是用户设置的，并且在任务运行过程中不会改变。函数 goodness() 的返回结果我们叫着 **动态优先级**，动态优先级是基于静态优先级计算出来的，并且综合考虑了其它各种情况。其完整代码如下：
```c
static inline int goodness(struct task_struct *p, int this_cpu,
                           struct mm_struct *this_mm) {
    int weight;

    weight = -1;
    if (p->policy & SCHED_YIELD)
        goto out;

    /* 普通任务，静态优先级为 nice */
    if (p->policy == SCHED_OTHER) {
        /* 根据任务剩余的时间对任务进行奖励 */
        weight = p->counter;

        /* 如果该任务已经没有剩余时间，则直接忽略 */
        if (!weight)
            goto out;

#ifdef CONFIG_SMP
        /* 根据 CPU 对任务权重进行奖励 */
        if (p->processor == this_cpu)
            weight += PROC_CHANGE_PENALTY;
#endif

        /* 根据内存空间对任务权重进行奖励 */
        if (p->mm == this_mm || !p->mm)
            weight += 1;
        weight += 20 - p->nice;
        goto out;
    }

    /* 实时任务，静态优先级为 rt_priority */
    weight = 1000 + p->rt_priority;
out:
    return weight;
}
```

对于实时任务，系统将其静态优先级 (rt_priority) 加上 1000 然后返回，这样能够确保所有实时任务的动态优先级都高于普通进程。而对于普通进程，系统除了考虑静态优先级 (nice) 之外，还会如下几个方面对优先级进行调整：
- 根据任务的剩余时间进行调整 
    如果一个任务剩余的 CPU 时间很多，就说明该任务之前得到的运行机会很少，可能是任务在等待某个外部事件 (例如 IO 事件) ，也可能是一直被高优先级的任务排挤。为了更加公平，系统在每次调度时会将任务的剩余时间作为权重的奖励，这样越到调度后期，剩余时间更多的任务就越有机会被调度。

- 根据 CPU 进行调整 
    在 SMP 架构中，如果将任务 p 继续运行在其上次运行的 CPU 上的话，可能能够提升 CPU 缓存与 TLB 的命中率。

- 根据任务的内存空间进行调整 
    代码中 `p->mm == this_mm` 用来判断任务 p 与当前任务的内存地址空间是否一样，如果等式成立，则说明两个任务是同一个进程中的两个线程；  
    而 `!p->mm` 用来判断任务 p 是否是内核线程，所有的内核线程都共享一个内存空间。  
    在这两种情况下切换任务的话运行效率会更高，因为进程切换时不用切换地址空间，所以调度器会为权重 +1 作为奖励。

# 0x03. 时间分配

- 普通任务  
    为了保证系统在时间分配上的公平性，O(n)调度器 按照 “轮” 来计量调度周期，在每轮调度中，调度器根据各个任务的优先级为其分配时间，当所有任务的时间片都消耗完了之后，本轮度结束，系统开启下一轮调度。如果一个普通任务已经没有了剩余时间，则会直接被忽略。

- 实时任务  
    不受调度周期的限制，因为实时任务的优先级最高，调度器要确保只要实时任务处于 Ready 状态，那么就立刻被调度到，本质上不存在预先分配时间的必须性。

# 0x04. 调度时机

调度这件事情在什么情况下会发生？  

1. 进程主动发起调度，搜索内核代码会发现大量的地方调用了 schedule() 方法
2. timer 发现当前进程已经耗尽了自己的时间，触发调度。
3. 用户修改进程优先级的时候，这一点很好理解。
4. 系统通过 fork() 创建新任务的时候，新任务的产生会导致系统产生调度需求。