# 0x00. 导读

[深入 Linux 的进程优先级](https://linux.cn/article-7325-1.html)  
[linux-sched](https://s3.shizhz.me/linux-sched/task)
# 0x01. 简介

# 0x02. 进程优先级

## 2.1 nice 值

对于操作系统用户来说，能看到的只有 nice 值，其它的静态优先级、动态优先级都是内核可见的。 nice 值可以影响静态优先级，而静态优先级又可以影响动态优先级。

`nice 值`，取值范围为 -20~19，默认为0。这个值越小，表示进程”优先级”越高，而值越大“优先级”越低。当nice值设定好了之后，除非我们用 renice 去改它，否则它是不变的。

## 2.2 优先级

`rtpriority`: 实时优先级 记录上文中的实时优先级，有效范围是 [1, 99], 数字越大优先级越高，当数值是0时表示该进程是普通进程。

`staticprio`: 静态优先级。

```c
#define NICE_TO_PRIO(nice)  (MAX_RT_PRIO + (nice) + 20)
#define PRIO_TO_NICE(prio)  ((prio) - MAX_RT_PRIO - 20)
#define TASK_NICE(p)        PRIO_TO_NICE((p)->static_prio)

// MAX_RT_PRIO = 100
// NICE_TO_PRIO 得到的是静态优先级，所以取值范围是 [100, 139]
```

`normalprio`: 归一化优先级 如果我们使用了不同的方式来刻画同一个概念，那么势必会带来管理上的麻烦，所谓归一化，就是设计一种转换方式，将这些不同的方法统一到同一种方法上去，从而简化问题的模型。
例如在前文中，我们提到 rtpriority 数字越大，优先级越高；nice 值则相反，而 deadline 进程始终要维持最高优先级。为了便于管理，内核设计了一种归一化算法，将所有的优先级统一到 [-1, 139] 这个区间上，并且数字越小优先级越大，该优先级就叫着归一化优先级。
所有优先级值在0-99范围内的，都是实时进程，所以这个优先级范围也可以叫做实时进程优先级，而100-139范围内的是非实时进程。

`prio`: 动态优先级 调度器工作时实际使用的优先级。

# 0x03. 时间⽚ (time slice)
表示进程被调度进来和被调度出去所能持续的时间⻓度；

# 0x04. Linux 调度器

调度器是整个系统的发动机，负责所有就绪进程的调度运⾏，设计良好的调度器需要从以下⼏个⽅⾯进⾏考虑：
- 吞吐量
- 响应时间
- 公平性
- 功耗 （移动设备）

调度类型
1. 主动放弃 CPU (由于需要等待或者主动进⼊ Sleep)
2. 被动放弃 CPU (由于时间⽚消耗完或被更⾼优先级的任务抢占-如⽀持抢占)

## 4.1 Linux 调度器历史
- O(n) 2.4 内核
- O(1) 2.6 内核
- CFS 2.6.23+ (当前默认调度器)

## 4.2 O(n) 调度算法


## 4.3 O(1) 调度算法

简单来说，时间片的思路就是将CPU的执行时间分成一小段一小段的，假如是 5ms 一段。于是多个进程如果要“同时”执行，实际上就是每个进程轮流占用 5ms 的 cpu 时间，而从 1s 的时间尺度上看，这些进程就是在“同时”执行的。  
当然，对于多核系统来说，就是把每个核心都这样做就行了。而在这种情况下，如何支持优先级呢？实际上就是将时间片分配成大小不等的若干种，优先级高的进程使用大的时间片，优先级小的进程使用小的时间片。这样在一个周期结速后，优先级大的进程就会占用更多的时间而因此得到特殊待遇。

算法还有一个比较特殊的地方是，即使是相同的 nice 值的进程，也会再根据其 CPU 的占用情况将其分成两种类型： CPU 消耗型和 IO 消耗性。  
典型的 CPU 消耗型的进程的特点是，它总是要一直占用 CPU 进行运算，分给它的时间片总是会被耗尽之后，程序才可能发生调度。比如常见的各种算数运算程序。  
而 IO 消耗型的特点是，它经常时间片没有耗尽就自己主动先释放CPU了，比如 vi，emacs 这样的编辑器就是典型的 IO 消耗型进程。

为什么要这样区分呢？因为 IO 消耗型的进程经常是跟人交互的进程，比如 shell、编辑器等。当系统中既有这种进程，又有 CPU 消耗型进程存在，并且其 nice 值一样时，假设给它们分的时间片长度是一样的，都是 500ms，那么人的操作可能会因为 CPU 消耗型的进程一直占用 CPU 而变的卡顿。可以想象，当 bash 在等待人输入的时候，是不占 CPU 的，此时 CPU 消耗的程序会一直运算，假设每次都分到 500ms 的时间片，此时人在 bash 上敲入一个字符的时候，那么 bash 很可能要等个几百 ms 才能给出响应，因为在人敲入字符的时候，别的进程的时间片很可能并没有耗尽，所以系统不会调度 bash 程度进行处理。为了提高 IO 消耗型进程的响应速度，系统将区分这两类进程，**并动态调整 CPU 消耗的进程将其优先级降低，而 IO 消耗型的将其优先级变高，以降低 CPU 消耗进程的时间片的实际长度**。不过这个动态调整的功能在调度器换成CFS之后就不需要了，因为CFS换了另外一种CPU时间分配方式。

## 4.4 CFS(Complete Fair Scheduler) 调度算法

早期的 CFS 实现只在进程层面上实现了时间的公平分配，例如，如果一个系统有 100 个进程， CFS 会保证每个进程都获得 1% 的 CPU 时间，但实际上系统中的这 100 个进程可能隶属于两个用户 A 与 B , 其中 用户A 拥有 10 个进程， 用户B 拥有 90 个进程，这种实现造成的结果是 用户A 只获得了 10% 的 CPU 时间，而 用户B 获得了 90% 的时间。如果 用户B 了解 CFS 的调度原理，那么他可以肆无忌惮地 fork 出更多的进程以攫取更多的 CPU 时间。   
可见 CFS 在进程层面上的公平，却导致了系统在用户层面上的不公平，甚至是漏洞。对于这种情况，一种更合理的策略是系统首先保证每个用户获得相同的时间，然后再对隶属于同一个用户的所有进程公平地分配该用户的时间。  
将该概念进一步抽象，我们就得到了 **进程组** 的概念。进程组的引入实际上是增加了一个调度层级，调度器首先完成进程组的时间分配，再处理组内进程之间的时间分配。

为了公平，思路是：如果当前有 n 个进程需要调度执行，那么调度器应该在一个比较小的时间范围内，把这 n 个进程全都调度执行一遍，并且它们平分 cpu 时间，这样就可以做到所有进程的公平调度。  
那么这个比较小的时间就是 **任意一个R状态进程被调度的最大延时时间，即：任意一个R状态进程，都一定会在这个时间范围内被调度相应。这个时间也可以叫做调度周期，其英文名字叫做：`sched_latency_ns` (对应还有一个 /proc/sys/kernel/sched_min_granularity_ns 用来设定进程被调度执行之后的最小CPU占用时间) 。** 进程越多，每个进程在周期内被执行的时间就会被平分的越小。调度器只需要对所有进程维护一个累积占用CPU时间数，就可以衡量出每个进程目前占用的 CPU 时间总量是不是过大或者过小，这个数字记录在每个进程的 vruntime 中。所有待执行进程都以 vruntime 为 key 放到一个由红黑树组成的队列中，每次被调度执行的进程，都是这个红黑树的最左子树上的那个进程，即 vruntime 时间最少的进程，这样就保证了所有进程的相对公平。

当然，CFS 中还需要支持优先级。在新的体系中，优先级是以时间消耗 (vruntime 增长) 的快慢来决定的。就是说，对于 CFS 来说，衡量的时间累积的绝对值都是一样纪录在 vruntime 中的，但是不同优先级的进程时间增长的比率是不同的，高优先级进程时间增长的慢，低优先级时间增长的快。  
比如，优先级为 19 的进程，实际占用 cpu 为 1 秒，那么在 vruntime 中就记录 1s 。但是如果是 -20 优先级的进程，那么它很可能实际占 CPU 用 10s ，在 vruntime 中才会纪录 1s 。CFS 真实实现的不同 nice 值的 cpu 消耗时间比例在内核中是按照“每差一级cpu占用时间差 10% 左右”这个原则来设定的。这里的大概意思是说，如果有两个 nice 值为 0 的进程同时占用 cpu ，那么它们应该每人占 50% 的 cpu ，如果将其中一个进程的 nice 值调整为 1 的话，那么此时应保证优先级高的进程比低的多占用 10% 的cpu，就是 nice 值为 0 的占 55% ， nice 值为 1 的占 45% 。那么它们占用 cpu 时间的比例为 55:45 。这个值的比例约为 1.25 。就是说，相邻的两个nice值之间的cpu占用时间比例的差别应该大约为1.25。

CFS 是通过 vruntime 最小值来选择需要调度的进程的，那么可以想象，在一个已经有多个进程执行了相对较长的系统中，这个队列中的 vruntime 时间纪录的数值都会比较长。如果新产生的进程直接将自己的 vruntime 值设置为 0 的话，那么它将在执行开始的时间内抢占很多的CPU时间，直到自己的 vruntime 追赶上其他进程后才可能调度其他进程，这种情况显然是不公平的。所以 CFS 对每个 CPU 的执行队列都维护一个 min_vruntime 值，这个值纪录了这个 CPU 执行队列中 vruntime 的最小值，当队列中出现一个新建的进程时，它的初始化 vruntime 将不会被设置为0，而是根据 min_vruntime 的值为基础来设置。这样就保证了新建进程的 vruntime 与老进程的差距在一定范围内，不会因为 vruntime 设置为 0 而在进程开始的时候占用过多的 CPU 。

系统中可能运行着各种类型的进程，用户对不同种类进程的期望值是不一样的，例如对于实时进程，我们希望进程具备超高的响应速度，进程一旦就绪就立马被调度到；而对于批处理进程，用户更多关注的是其吞吐量，只要他能够在后台默默运行完成就OK, 因此对于调度器而言，不同的进程类型意味着不同的调度逻辑。所以引入调度类 (Sched Class) 的概念，意在将调度逻辑模块化。

调度类一共有 5 类：
1. Stop: Stop 是特殊的调度类，内核使用该调度类来停止 CPU. 该调度类用来强行停止 CPU 上的其他任务，由于该调度类的优先级最高，因此一旦生效就将抢占任何当前正在运行的任务，并且在运行过程中自己不会被抢占。
该调度类只有在 SMP 架构的系统中存在，内核使用该调度类来完成负载均衡与 CPU 热插拔等工作。
2. Deadline: 有些任务必须在指定时间窗口内完成。例如视频的编码与解码，CPU 必须以特定频率完成对应的数据处理；这类任务是优先级最高的用户任务，CPU 应该首先满足。优先级仅仅低于 Stop 调度类。
3. RT: 实时任务 (Real-time Task) 对响应时间要求更高，例如编辑器软件，它可能由于等待用户输入长期处于睡眠之中，但一旦用户有输入动作，我们就期望编辑器能够立马响应，而不是等系统完成其它任务之后才开始反应，这一点对用户体验十分重要。
4. CFS: Fair 调度类用来调度绝大多数用户任务，CFS 实现的就是这种调度类，其核心逻辑是根据任务的优先级公平地分配 CPU 时间，引入虚拟运行时间概念。
5. IDLE-Task: 与 Stop 类似，Idle 调度类也是仅供内核使用的特殊调度类，其优先级最低，只有在没有任何用户任务时才会用到。内核会为每个 CPU 绑定一个内核线程 (kthread) 来完成该任务，该线程会在队列无事可做的情况下启动该任务，并将 CPU 的功耗降到最低。

![Alt text](../../pic/sched/SchedClassOrder.png)

调度类实际上是根据优先级对任务的一个粗略划分，调度器总是从高优先级的调度类开始寻找可执行的任务。但对于同一个调度类中的多个任务，如果他们的优先级相同的话，调度器如何决定该选哪一个呢？  
这个问题通过调度策略 (Sched Policy， 一共六种) 来解决，不同调度类的调度策略实现如下：

- Stop 调度类  
Stop 调度类中只有一个任务可供执行，不需要定义任何调度策略。

- DL （Deadline）调度类  
DL 只实现了一种调度策略: `SCHED_DEADLINE`, 用来调度优先级最高的用户任务。

- RT （Real-Time）  
RT 提供了两种调度策略: `SCHED_FIFO` 与 `SCHED_RR`.  
    - 对于使用 SCHED_FIFO 的任务，其会一直运行到主动放弃 CPU;  
    - 而对于 SCHED_RR 的任务，如果多个任务的优先级相同，则大家会按照一定的时间配额来交替运行，即使一个任务一直处于可运行状态，在使用完自己的时间切片之后也会被抢占，然后被放入队列的尾巴等待下次机会。

- Fair CFS 实现了三种调度策略: 
    1. `SCHED_NORMAL`: 被用于绝大多数用户进程
    2. `SCHED_BATCH`: 适用于没有用户交互行为的后台进程，用户对该类进程的响应时间要求不高，但对吞吐量要求较高，因此调度器会在完成所有 SCHED_NORMAL 的任务之后让该类任务不受打扰地跑上一段时间，这样能够最大限度地利用缓存。
    3. `SCHED_IDLE`: 这类调度策略被用于系统中优先级最低的任务，只有在没有任何其他任务可运行时，调度器才会将运行该类任务。

- Idle 同 Stop 一样，Idle 调度类也没有实现调度策略，注意不要将这类调度类与 CFS 中的 SCHED_IDLE 混淆。

调度策略的定义如下：
```c
#define SCHED_NORMAL 0
#define SCHED_FIFO 1
#define SCHED_RR 2
#define SCHED_BATCH 3
/* SCHED_ISO: reserved but not implemented yet */
#define SCHED_IDLE 5
#define SCHED_DEADLINE 6

// 可以通过 /proc/<pid>/sched 中的内容来查看进程的调度策略
// grep 'policy' /proc/11742/sched
```


CFS 调度器中使⽤静态优先级对应的权重概念来对应。权重的对应关系（-20 - 19）。进程每降低⼀个 nice 值，将多获得 10% CPU 的时间。

vruntime (virtual runtime): 表示该进程已经在 CPU 上运⾏的时间，值越⼤被再次调度概率越低。

进程的 vruntime 增⻓速度取决于其优先级: 
- 优先级越低，则 vruntime 增⻓越快，因⽽被再次调⽤的可能性就越⼩
- 优先级越⾼，则 vruntime 增⻓越慢，因⽽被再次调⽤的可能性就越⼤

# 0x05. 优先级

在前面讨论调度类与调度策略时，我们反复地提到优先级，因为不管是调度类还是调度策略，本质上都是在对任务按照优先级排序。

> 优先级并不是隐藏在内核中的概念，对于Linux用户而言，更加熟悉的是进程的 nice 值。 nice 值的范围是 [-20, 19], 数字越低优先级越高。可以理解为一个进程的 nice 数值越大就对其他进程越 nice, 因此越愿意让渡自己的CPU时间，最终自己得到的时间就越少。
> 用户可以通过 top 命令的 NI 这一列查看进程的 nice 值， 用户可以在启动程序时指定 nice 值，也可以对已经运行的程序通过 renice 命令进行修改。进程启动进程时，nice 的默认值是0。

优先级是调度器工作的重要基础，优先级如何使用取决于调度类的调度算法，我们先分类来看一下：

- Deadline 进程。 DL调度类使用 EDF(Earliest Deadline First) 算法来对多个 Deadline 进程进行调度，即谁的 Deadline 在前面，就选择谁来执行，优先级不在调度逻辑的考虑之中。[详细的调度算法参考](https://www.kernel.org/doc/html/latest/scheduler/sched-deadline.html) 。

    因此所有 Deadline 类型的进程优先级都是 -1, 该值其实相当于只是一个标识符，用来表示当前进程是Deadline类型，在系统中优先级最高，仅此而已。

- 实时进程。 RT 调度类的逻辑很简单：永远挑优先级最高的进程执行，如果优先级相同，则根据调度策略进行选择。  
    RT 优先级的范围是 [1, 99], 其中 99 的优先级最高。

- 普通进程。 普通进程被 CFS 调度，该类进程的优先级就是进程的 nice 值。

可见，只有实时进程与普通进程的优先级会参与调度逻辑。内核在处理 nice 时会加上120, 完成 nice 值与静态优先级之间的转换
