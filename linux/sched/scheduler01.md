# 0x00. 导读

[linux-sched](https://s3.shizhz.me/linux-sched/task)

# 0x01. 简介

进程调度是对 TASK_RUNNING 状态的进程进行调度。调度程序的最大原则在于能够最大限度的利用计算资源。

# 0x02. 调度器

linux 操作系统需要解决几个互相冲突的目标

- 进程响应时间尽可能快
- 后台作业的吞吐量即可能高
- 尽可能避免进程的饥饿现象
- 低优先级和高优先级进程的需要尽可能调和

简答概况就是要有一个办法，**决定什么时候以一种怎么样的方式选择一个新进程占用CPU运行，并且大家都拍手较好，谁也没有二话**。

![Alt text](../../pic/linux/sched/scheduler_purpose.png)

## 2.1 为什么能调度

协作式多任务叫做主动调度（进程任务一旦占用 CPU 只有当任务完成或者因为某些原因主动释放 CPU ），抢占式多任务叫做被动调度（进程任务占用CPU期间可以被其他进程夺走，具体由操作系统调度器决定下一个占用CPU的进程，Linux 采用抢占式调度）。

为什么能调度分为两部分：为什么能触发调度和为什么能执行调度。

对于主动调度，调度是进程主动触发的，这个是肯定能的。

对于被动调度，在图灵机模型中是做不到的，因为图灵机是一条线性一直往前走的，进程在执行时，进程要是不主动，是不可能跳到其它进程来执行的。被动调度能做到的原因关键就在于**中断机制**，因为中断是强行在正常的执行流中插入了一段代码，它能改变后续代码的走向。有了中断机制，我们就可以创建一个定时器中断，以固定的时间间隔比如每 10ms 来触发中断，检测进程是否运行时间过长，如果过长就触发调度。这样任何进程都不可能霸占 CPU ，所以进程都能公平地共享 CPU 时间。

有了中断机制之后，在中断的处理中可以触发调度，在中断返回的点可以执行调度，这样就可以避免进程霸占CPU了。

前面说的是为何能触发进程调度，主动调度是进程自己触发的，被动调度是在中断中触发的。现在来看看为何能执行调度，执行调度包括两部分：选择进程和切换进程。选择进程是纯软件的，肯定能实现。切换进程是怎么切换呢？进程切换主要是切换执行栈和用户空间，这两个都需要用到 CPU 特定的指令。

## 2.2 执行调度

执行调度分为两步：一是选择下一个要执行的进程，二是切换进程。  

选择下一个要执行的进程，这就是调度算法了。首先调度算法只能从Runnable的进程中进行选择，不能选择Blocked进程，因为选择了也没有意义。其次算法还要区分进程类型，比如普通进程与实时进程，肯定要优先选择实时进程，在同一类型的进程中还要有具体的算法来决定到底选择哪个进程。在Linux中一共把进程分为了5类，每一类都有一个具体的算法。类之间的关系是优先选择高类的进程，只有当高类没有Runnable进程时才会去选择低类进程。

进程选择好了之后就要切换进程了。切换进程分两步：第一步是切换用户空间，第二步是切换执行栈(线程栈)。

## 调度器种类

时间片、优先级、runqueue

- [O(n)调度算法](./O(n)调度算法.md) 2.4 内核
- [O(1)调度算法](./O(1)调度算法.md) 2.6 内核
- [CFS调度算法](./CFS调度算法.md) 2.6.23+ (当前默认调度器)
