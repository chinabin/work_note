# 0x00. 导读

# 0x01. 简介

内联汇编是将一些汇编语言的指令以内联函数的形式写入 C 语言代码中， 并且可以通过 C 语言的变量输入/输出，实现了汇编语言和 C 语言语言的联合编程。 为了使用内联汇编，GCC 和 Clang 均提供了 asm 关键词。

内联汇编既有内联函数的内联特性，又可以充分利用计算机性能。 但是，内联汇编但缺点也很明显，受限于汇编语言的硬件相关性，包含内联汇编的代码通常不具备良好的跨平台特性。

当前版本的 GCC/GNU 编译器和 Clang/LLVM 编译器默认使用 AT&T/UNIX 汇编语法， GCC 可以通过加参数 -masm=intel 来使用 Intel 汇编语法，该参数并不适用于 Clang。

# 0x02. 汇编语法

在 AT&T/UNIX 语法中：

- 第一操作数为源操作数，第二操作数为目的操作数。也就是说，AT&T/UNIX 语法中的 `Op-code src dst`.

- 寄存器名称有 % 前缀，即如果要使用 eax 寄存器，它应该写作 `%eax`。 

- C 语言的变量和立即数都以 $ 作为前缀，同时常量立即数可以添加前缀 0x 表示十六进制。 

- 存储器操作数的大小取决于操作数名字的后缀。 后缀 b、w、l 分别指明了 字节byte（8位）、字word（16位）、长型long（32位）的存储器引用。

- 基址寄存器包含在 ( 和 ) 中，间接内存引用表示为 section:disp(base, index, scale)，当一个立即数用于 disp 或 scale 时，不能添加 $ 前缀。

# 0x03. C 语言内联汇编的语法

GCC/Clang 提供的关键字 asm 可以直接用来使用内联汇编代码，`__asm__` 是它的别名，可以避免 asm 与其它标识符冲突。

GCC/Clang 提供了两种内联汇编的使用方法，分别是 **基本汇编** 和 **扩展汇编** 。

## 4.1 基本汇编

基本汇编的语法直接了当。它的基本格式为
```c
asm ("汇编代码");
asm ("movl %ecx %eax");  /* 将 ecx 寄存器的内容移至 eax */
asm ("movb %bh (%eax)"); /* 将 bh 的一个字节数据 移至 eax 寄存器指向的内存 */

```

如果指令多于一条，可以一行一条，并用双引号圈起，同时为每条指令添加 `\n\t` 后缀。 这是因为 GCC 将每一条当作字符串发送给 GNU 汇编器，并且通过使用换行符/制表符发送正确格式化后的行给汇编器。

```c
asm ("movl %eax, %ebx\n\t"
     "movl $56, %esi\n\t"
     "movl %ecx, $label(%edx,%ebx,$4)\n\t"
     "movb %ah, (%ebx)");

```

**如果在汇编代码中涉及到一些寄存器，即改变其内容，在没有恢复这些变化的情况下从汇编中返回，会导致一些意想不到的事情。 这是因为 GCC 并不知道寄存器内容的变化，这会导致不可预料的问题，特别是当编译器做了某些优化时。 因此在基本汇编中通常只能使用没有副作用的指令。如果想要使用改变寄存器的指令，则需要在内联汇编退出时恢复这些寄存器。** 扩展汇编给我们提供了这个功能。

## 4.2 扩展汇编

