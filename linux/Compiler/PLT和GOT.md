# 0x00. 导读

# 0x01. 简介

[PLT与GOT](https://www.binss.me/blog/plt-and-got/)

我们知道，函数调用就是在压入参数后对函数地址 call 一下，而由于编译时的局部性，对于定义在其他文件中的函数，编译时编译器会留下一个坑，等到链接时链接器会对坑进行填坑。但是对于定义在动态链接库中的函数，比如 glibc 中的函数 printf 来说，显然此时是不知道函数地址的，需要等到运行时才能进行填坑。

但由于现代操作系统不允许对代码段进行修改(也不应该修改，考虑动态链接库函数调用动态链接库函数的情况)，不能在运行时直接填坑，因此只能采取比较间接的方法。比如函数利用 data 段存储的坑进行跳转，而 data 段的坑在运行时进行填坑。但是我们又不想一开始就把所有的坑给填了(后文会提到)，于是采取了比较间接的方式：

先让坑指向一段同样位于代码段的代码，这段代码判断坑是否被填，如果没填，填之；如果填了，直接调用函数。

这段代码段被定义为 **过程连接表(Procedure Linkage Table，PLT)** ，而 data 段中的坑被定义为 **全局偏移表(Global Offset Table, GOT)** 。


PLT是位于text段的一张表，每个表项由三行代码组成，总长度为0x10，有多少个动态链接的函数就有多少个表项。

GOT是位于data段的一张表，每个表项用于存放动态链接函数的地址。在填坑前存放的是PLT表项第二条指令的地址。

当动态链接的函数第一次被调用时，跳转到对应的PLT表项，在第一个指令中根据对应GOT表项进行跳转，由于此时未填坑，跳转到PLT表项的第二条指令，压入参数，在第三个指令中跳转到printf@plt-0x10，由它负责调用_dl_runtime_resolve_avx进行填坑并执行一次调用。

于是在后续调用时，跳转到对应的PLT表项，在第一个指令中根据对应GOT表项进行跳转，由于此时已填坑，跳转到动态链接库的对应函数中进行执行。

# 0x02. 