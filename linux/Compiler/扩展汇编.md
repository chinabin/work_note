# 0x00. 导读

[汇编指令速查](https://www.cnblogs.com/lsgxeva/p/8948153.html)

# 0x01. 简介

# 0x02. 扩展汇编

在扩展汇编中，我们可以同时指定操作数。它允许我们指定输入寄存器、输出寄存器以及修饰寄存器列表。 GCC 不强制用户必须指定使用的寄存器。

扩展汇编的基本格式为：  
```c
asm ( 汇编程序模板
    : 输出操作数     /* 可选的 */
    : 输入操作数     /* 可选的 */
    : 修饰寄存器列表  /* 可选的 */
    );

```

- **汇编程序模板** 由汇编指令组成。
- 每一个操作数由一个操作数约束字符串所描述，其后紧接一个括弧括起的 C 语言表达式。 
- 冒号用于将汇编程序模板和第一个输出操作数分开，另一个（冒号）用于将最后一个输出操作数和第一个输入操作数分开（如果存在的话）。   
```c
asm ("cld\n\t"
     "rep\n\t"
     "stosl"
    :                                       /* 无输出 */
    :"c"(count), "a"(fill_value), "D"(dest) /* 输入列表 */
    :"%ecx", "%edi"                         /* 修饰寄存器列表 */
    );

```
以上的内联汇编是将 fill_value 的值连续 count 次拷贝到寄存器 edi 所指位置 （每执行 stosl 一次，寄存器 edi 的值会递增或递减，这取决于是否设置了 direction 标志，因此以上代码实则初始化一个内存块）。 它也告诉 GCC 寄存器 ecx 和 edi 一直无效。

为了更加清晰地说明，让我们再看一个示例：
```c
int a = 10, b;
asm ("movl %1, %%eax;
      movl %%eax, %0;"
    :"=r"(b)        /* 输出列表 */
    :"r"(a)         /* 输入列表 */
    :"%eax"         /* 修饰寄存器列表 */
    );

```
这个示例的作用是使用汇编指令使变量 b 的值等于变量 a 的值。其中：

- b 为输出操作数，用 %0 引用，a 为输入操作数，用 %1 引用。
- "r" 和 "=r" 为操作数约束字符串。之后会更详细地介绍约束。 这里 r 告诉 GCC 可以使用任一寄存器存储操作数。输出操作数约束应该有一个约束修饰符 =，表明它是一个只读的输出操作数。
- 寄存器名字以两个 % 为前缀。这有利于 GCC 区分操作数和寄存器。操作数以一个 % 为前缀。
- 第三个冒号之后的修饰寄存器 %eax 用于告诉 GCC %eax 的值将会在 asm 内部被修改，所以 GCC 将不会使用此寄存器存储任何其他值。

# 0x03. 汇编程序模板

汇编程序模板包含了被插入到 C 语言程序的汇编指令集。 其格式为：每条指令用双引号圈起，或者整个指令组用双引号圈起。 同时每条指令应以分界符结尾。有效的分界符有换行符 `\n` 和分号 `;`，`\n` 可以紧随一个制表符 `\t`。

# 0x04. 输入操作数和输出操作数

扩展汇编的每个操作数是一个用括弧圈起的 C 语言表达式，前面是以双引号圈起的操作数约束字符串。约束字符串主要用于决定操作数的寻址方式，同时也用于指定使用的寄存器。

当操作数多于一个时，用逗号隔开。

每个操作数在汇编程序模板中用数字引用。编号方式索引初始值为 0。操作数的最大个数在前一节介绍过。

输出操作数表达式必须为左值。输入操作数的要求不像这样严格。它们可以为表达式。 扩展汇编特性常常用于编译器所不知道的机器指令。如果输出表达式无法直接寻址（即它是一个位域），我们的约束字符串必须给定一个寄存器。 在这种情况下，GCC 将会使用该寄存器作为汇编的输出，然后存储该寄存器的内容到输出。

正如前面所陈述的一样，普通的输出操作数必须为只写的； GCC 将会假设指令前的操作数值是死的，并且不需要被（提前）生成。扩展汇编也支持输入-输出或者读-写操作数。

```c
asm ("leal (%1,%1,4), %0"
    :"=r"(five_times_x)
    :"r"(x)
    );

```

# 0x05. 修饰寄存器列表

一些指令会修改一些硬件寄存器内容。我们不得不在修饰寄存器列表中列出这些寄存器，即扩展汇编内第三个 : 之后的部分。 这可以告知 GCC 汇编指令将会使用和修改这些寄存器，这样 GCC 就不会假设存入这些寄存器的值是有效的。 不用在这个列表里列出输入、输出寄存器。因为它们被显式地指定了约束，GCC 可以推断 asm 使用了它们。 如果指令隐式或显式地使用了任何除此之外的其他寄存器，那么就需要在修饰寄存器列表中指定这些寄存器。

如果指令会修改 条件码寄存器（又称 状态寄存器 或 标志寄存器），则必须将 %cc 添加进修饰寄存器列表。

如果我们的指令以不可预测的方式修改了内存，那么需要将 memory 添加进修饰寄存器列表。 这可以使 GCC 不会在汇编指令间保持缓存于寄存器的内存值。如果被影响的内存不在汇编的输入或输出列表中，我们也必须添加 volatile 关键词。

```c
asm ("movl %0,%%eax;
      movl %1,%%ecx;
      call _foo"
    : /* no outputs */
    :"g"(from), "g"(to)
    :"eax", "ecx"
    );

```

如果汇编语句必须在我们放置它的地方执行（例如，不能为了优化而被移出循环语句），将 C 语言标准的关键词 volatile 放置在 asm 后面、() 的前面。 以避免编译器不可预知的优化，防止它被移动、删除或者其他操作。内核源码经常会有这种写法。  
```c
asm volatile ( 汇编程序模板
             : 输出操作数     /* 可选的 */
             : 输入操作数     /* 可选的 */
             : 修饰寄存器列表  /* 可选的 */
             );

```
类似于 __asm__，__volatile__ 是 volatile 的别名，可以避免 volatile 与其它标识符冲突。

# 0x06. 关于操作数约束字符串

约束和内联汇编有很大的关联。约束用于表明

- 操作数是否可以位于寄存器和位于哪种寄存器
- 操作数是否可以是一个内存引用和哪种地址
- 操作数是否可以是一个立即数和可能的取值范围，等等

## 6.1 常用约束

- 寄存器操作数约束 r

    当使用这种约束指定操作数时，它们存储在 通用寄存器 中，例如
    ```c
    asm ("movl %%eax, %0\n" :"=r"(myval));
    ```
    变量 myval 保存在寄存器中，寄存器 eax 的值被复制到该寄存器中，然后 myval 的值从寄存器更新到了内存。

    还可以指定其它特定的寄存器：
    - r: Register(s)
    - a: %eax %ax %al
    - b: %ebx %bx %bl
    - c: %ecx %cx %cl
    - d: %edx %dx %dl
    - S: %esi %si
    - D: %edi %di

- 内存操作数约束 m

    m 约束允许一个内存操作数，可以使用机器普遍支持的任一种地址。 当操作数位于内存时，任何对它们的操作将直接发生在内存位置，这与寄存器约束相反，后者首先将值存储在要修改的寄存器中，然后将它写回到内存位置。 但寄存器约束通常用于一个指令必须使用它们或者它们可以大大提高处理速度的地方。 当需要在 asm 内直接更新一个 C 变量，而又不想使用寄存器去保存它的值，使用内存最为有效。例如，将 IDTR 寄存器的值存储于内存位置 loc 处：
    ```c
    asm ("sidt %0\n" : :"m"(loc));
    ```

- 匹配（数字）约束

    在某些情况下，一个变量可能既充当输入操作数，又充当输出操作数。可以通过使用匹配约束在 asm 中指定这种情况。示例代码：
    ```c
    asm ("incl %0" :"=a"(var):"0"(var));
    ```
    这个匹配约束的示例中，寄存器 %eax 既用作输入变量，也用作输出变量。 var 输入被读进 %eax，并且等递增后更新的 %eax 再次被存储进 var。 这里的 0 用于指定与第 0 个输出变量相同的约束。该约束可用于：

    - 在输入从变量读取或变量修改后且修改被写回同一变量的情况
    - 在不需要将输入操作数实例和输出操作数实例分开的情况

    使用匹配约束最重要的意义在于它们可以有效地使用可用寄存器。

- 一些其它通用约束

    - o 约束：允许一个内存操作数，但只有当地址是可偏移的时。即，该地址加上一个小的偏移量可以得到一个有效地址
    - V 约束：一个不允许偏移的内存操作数。换言之，任何适合 “m” 约束而不适合 “o” 约束的操作数
    - i 约束：允许一个（带有常量）的立即整形操作数，这包括其值仅在汇编时期知道的符号常量
    - n 约束：允许一个带有已知数字的立即整形操作数。许多系统不支持汇编时期的常量，因为操作数少于一个字宽。对于此种操作数，约束应该使用 n 而不是 i
    - g 约束：允许任一寄存器、内存或者立即整形操作数，不包括通用寄存器之外的寄存器

- x86 架构特有的约束

    - r 约束：寄存器操作数约束，查看上面第 1 条
    - q 约束：寄存器 a、b、c 或者 d
    - I 约束：范围从 0 到 31 的常量（对于 32 位移位）
    - J 约束：范围从 0 到 63 的常量（对于 64 位移位）
    - K 约束：0xff
    - L 约束：0xffff
    - M 约束：0、1、2 或 3（lea 指令的移位）
    - N 约束：范围从 0 到 255 的常量（对于 out 指令）
    - f 约束：浮点寄存器
    - t 约束：第一个（栈顶）浮点寄存器
    - u 约束：第二个浮点寄存器
    - A 约束：指定 a 或 d 寄存器。这主要用于想要返回 64 位整形数，使用 d 寄存器保存最高有效位和 a 寄存器保存最低有效位

## 6.2 约束修饰符

当使用约束时，对于更精确的控制超过了对约束作用的需求，GCC 给我们提供了约束修饰符。最常用的约束修饰符为：

- = 约束修饰符：意味着对于这条指令，操作数为只写的，旧值会被忽略并被输出数据所替换
- & 约束修饰符：意味着这个操作数为一个早期改动的操作数，其在该指令完成前通过使用输入操作数被修改了。 因此，这个操作数不可以位于一个被用作输出操作数或任何内存地址部分的寄存器。 如果在旧值被写入之前它仅用作输入而已，一个输入操作数可以为一个早期改动操作数。