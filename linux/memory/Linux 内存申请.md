# 0x00、导读

# 0x01

[Linux 内存空间分布](./Linux%20%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%88%86%E5%B8%83.md)

在虚拟内存空间的 normal memory 区域，内核使用 kmalloc() 来分配内存， kmalloc() 返回的也是虚拟地址，但是分到的内存在物理地址上是连续的（因为是直接映射，在虚拟地址上自然也是连续的）。

在 VMALLOC_START 和 VMALLOC_END 之间的区域为 vmolloc area ，它和 normal memory 中有 8MB 的间隔。这部分间隔不作任何地址映射，相当于一个空洞，主要用做安全保护，防止不正确的越界内存访问，因为此处没有进行任何形式的映射，如果进入到空洞地带，将会触发处理器产生一个异常。

在 vmolloc area 中使用 vmalloc() 分配内存， vmalloc area 中的地址映射不再是简单的3GB偏移，需要建立虚拟地址和物理页面的映射关系，并添加到内核页表中。并且 vmalloc() 分配的内存只能保证在虚拟地址上连续，不能保证在物理地址上连续。


![1](../../pic/linux/memory/kernel-virtmem-map.png)


1. kmalloc/kfree 申请的是较小的连续的物理内存，虚拟地址上也是连续的。kmalloc和get_free_page最终调用实现是相同的，只不过在调用最终函数时所传的flag不同而已。除非被阻塞否则他执行的速度非常快，而且不对获得空间清零。
2. get_free_page()申请的内存是一整页，一页的大小一般是128K。
3. kzalloc 先是用 kmalloc() 申请空间 , 然后用 memset() 清零来初始化 ,所有申请的元素都被初始化为 0.
4. vmalloc/vfree 用于申请较大的内存空间，虚拟内存是连续，但是在物理上它们不要求连续。
5. malloc 用于用户空间申请内存。除非被阻塞否则他执行的速度非常快，而且不对获得空间清零。

kmalloc 和 vmalloc 是分配的是内核的内存, malloc 分配的是用户的内存。
kmalloc()分配的内存属于 LowMem
vmalloc()分配的内存在 VMALLOC_START ~ VMALLOC_END 之间，HighMem 的底部。

mmap：可以避免内核空间到用户空间拷贝的过程，直接把文件映射成一个虚拟地址指针，指向linux内核申请的page cache。也就知道page cache和硬盘里文件的对应关系。

其中堆空间始于进程的数据段结束地址，也就是 start_brk ，随着内存的分配和释放而增加和减少，堆空间其实就是一段连续的虚拟内存空间，而通常将堆的当前内存边界称为 Program break 简称为 brk ， brk 用于记录的是当前堆已经分配使用的结束地址（即未使用分配的起始地址）。


用ps -o majflt,minflt -C program命令查看。

          majflt代表major fault，中文名叫大错误，minflt代表minor fault，中文名叫小错误。

          这两个数值表示一个进程自启动以来所发生的缺页中断的次数。

发成缺页中断后，执行了那些操作？

当一个进程发生缺页中断的时候，进程会陷入内核态，执行以下操作： 
1、检查要访问的虚拟地址是否合法 
2、查找/分配一个物理页 
3、填充物理页内容（读取磁盘，或者直接置0，或者啥也不干） 
4、建立映射关系（虚拟地址到物理地址） 
重新执行发生缺页中断的那条指令 
如果第3步，需要读取磁盘，那么这次缺页中断就是majflt，否则就是minflt。 