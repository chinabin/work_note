# 0x00、导读

## Buddy System

1. 伙伴系统的基本管理单位是区域，最小分配粒度是页面。
2. 伙伴系统并不是直接管理一个个页帧的，而是把页帧组成页块( pageblock )来管理。
    - 页块是由连续的 2^n 个页帧组成， n 叫做这个页块的阶，范围是 0 到 10 。
    - 对齐，n 阶的页块首页帧的页帧号( PFN )必须是 2^n 的倍数。  
        比如 3 阶页块的首页帧( PFN )必须除以 8(2^3) 能除尽， 10 阶页块的首页帧必须除以 1024(2^10) 能除尽。 0 阶页块只包含一个页帧，任意一个页帧都可以构成一个 0 阶页块，而且符合对齐要求，因为任何整数除以 1(2^0) 都能除尽。
3. `__alloc_pages`，内核、用户都可以用。
4. `/proc/buddyinfo`

## Slab Allocator

1. 先从伙伴系统中分配一些页面，然后把这些页面切割成一个个同样大小的基本块，用户就可以从 slab 中申请分配一个同样大小的内存块了。如果 slab 中的内存不够用了，它会再向伙伴系统进行申请。  
不同的 slab 其基本块的大小并不相同，内核的每个模块都要为自己的特定需求分配特定的 slab ，然后再从这个 slab 中分配内存。
2. `kmem_cache_create kmem_cache_alloc`
3. `/proc/slabinfo`

## kmalloc

1. 内存中还有一些偶发的零碎的内存分配需求，一个模块如果仅仅为了分配一次 5 字节的内存，就去创建一个 slab ，那显然不划算。  
为此内核创建了一个统一的零碎内存分配器 kmalloc ，用户可以直接请求 kmalloc 分配若干个字节的内存。  
Kmalloc 底层用的还是 slab 机制， kmalloc 在启动的时候会预先创建一些不同大小的 slab ，用户请求分配任意大小的内存， kmalloc 都会去大小刚刚满足的 slab 中去分配内存。
2. kmalloc

## Vmalloc

## CMA

# 0x0

[Linux 内存空间分布](./Linux%20%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%88%86%E5%B8%83.md)

在虚拟内存空间的 normal memory 区域，内核使用 kmalloc() 来分配内存， kmalloc() 返回的也是虚拟地址，但是分到的内存在物理地址上是连续的（因为是直接映射，在虚拟地址上自然也是连续的）。

在 VMALLOC_START 和 VMALLOC_END 之间的区域为 vmolloc area ，它和 normal memory 中有 8MB 的间隔。这部分间隔不作任何地址映射，相当于一个空洞，主要用做安全保护，防止不正确的越界内存访问，因为此处没有进行任何形式的映射，如果进入到空洞地带，将会触发处理器产生一个异常。

在 vmolloc area 中使用 vmalloc() 分配内存， vmalloc area 中的地址映射不再是简单的3GB偏移，需要建立虚拟地址和物理页面的映射关系，并添加到内核页表中。并且 vmalloc() 分配的内存只能保证在虚拟地址上连续，不能保证在物理地址上连续。


![1](../../pic/linux/memory/kernel-virtmem-map.png)


1. kmalloc/kfree 申请的是较小的连续的物理内存，虚拟地址上也是连续的。kmalloc和get_free_page最终调用实现是相同的，只不过在调用最终函数时所传的flag不同而已。除非被阻塞否则他执行的速度非常快，而且不对获得空间清零。
2. get_free_page()申请的内存是一整页，一页的大小一般是128K。
3. kzalloc 先是用 kmalloc() 申请空间 , 然后用 memset() 清零来初始化 ,所有申请的元素都被初始化为 0.
4. vmalloc/vfree 用于申请较大的内存空间，虚拟内存是连续，但是在物理上它们不要求连续。
5. malloc 用于用户空间申请内存。除非被阻塞否则他执行的速度非常快，而且不对获得空间清零。

kmalloc 和 vmalloc 是分配的是内核的内存, malloc 分配的是用户的内存。
kmalloc()分配的内存属于 LowMem
vmalloc()分配的内存在 VMALLOC_START ~ VMALLOC_END 之间，HighMem 的底部。

mmap：可以避免内核空间到用户空间拷贝的过程，直接把文件映射成一个虚拟地址指针，指向linux内核申请的page cache。也就知道page cache和硬盘里文件的对应关系。

其中堆空间始于进程的数据段结束地址，也就是 start_brk ，随着内存的分配和释放而增加和减少，堆空间其实就是一段连续的虚拟内存空间，而通常将堆的当前内存边界称为 Program break 简称为 brk ， brk 用于记录的是当前堆已经分配使用的结束地址（即未使用分配的起始地址）。


用ps -o majflt,minflt -C program命令查看。

          majflt代表major fault，中文名叫大错误，minflt代表minor fault，中文名叫小错误。

          这两个数值表示一个进程自启动以来所发生的缺页中断的次数。

发成缺页中断后，执行了那些操作？

当一个进程发生缺页中断的时候，进程会陷入内核态，执行以下操作： 
1、检查要访问的虚拟地址是否合法 
2、查找/分配一个物理页 
3、填充物理页内容（读取磁盘，或者直接置0，或者啥也不干） 
4、建立映射关系（虚拟地址到物理地址） 
重新执行发生缺页中断的那条指令 
如果第3步，需要读取磁盘，那么这次缺页中断就是majflt，否则就是minflt。 