# 0x0 导读

1. 内存分页是什么？
2. 内存分页机制是什么？
3. 内存分页好处和坏处是什么？如何改进？

# 0x01 简介

    分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间，我们叫页（Page）。在 Linux 下，每一页的大小为 4KB。

    这样一切分，内存碎片自然就出现的少了。另外，当需要进行内存交换的时候，需要交换写入或者从磁盘装载的数据也更少了。

虚拟地址通过 MMU(Memory Management Unit) 和 页表(page table) 来转换为物理地址。

MMU是处理器/核 (processer) 中的一个硬件单元，通常每个核有一个MMU。MMU由两部分组成：
- TLB( Translation Lookaside Buffer ) ，通常称为页表缓存、转址旁路缓存、快表。
- table walk unit。

page table 是每个进程独有的，是软件实现的，是存储在内存中的。

# 0x02 机制

1. CPU 给出一个 virtual address

2. 首先查找 TLB ，存在则称为 TLB hit ，直接得到对应的物理地址。

3. TLB miss, 需要 MMU 的 table walk unit 来查找 page table.    
    如果在 page table 存在，检查 p(present) 位：
    - 为 1 
        - 更新 TLB ，因为我之所以到这一步就是因为 TLB 里面没有
        - 权限检测，如果没有正确权限，则触发 SIGSEGV(Segmantation Fault)
    - 为 0 ，触发 page fault，之所以为 0 ，可能因为
        - 这个虚拟地址被分配后还从来没有被 access 过（比如 malloc 之后还没有操作分配到的空间，则不会真正分配物理内存）。触发 page fault 后分配物理内存，也就是 demand paging ，有了确定的 demand 了之后才分，然后将 p 位置 1。
        - 对应的这个物理页面的内容被换出到外部的 disk/flash 了，这个时候 page table entry 里存的是换出页面在外部 swap area 里暂存的位置，可以将其换回物理内存，再次建立映射，然后将 p 位置 1。

4. 如果不存在，产生 page fault ，操作系统从硬盘将其加载到内存。


# 0x03 页表

在分页机制下，虚拟地址分为两部分，页号和页内偏移。

页号作为页表的索引，页表包含物理页每页所在物理内存的基地址，这个基地址与页内偏移的组合就形成了物理内存地址，见下图。

![1](../../pic/linux/memory/m4.png)

对于一个内存地址转换，其实就是这样三个步骤：

- 把虚拟内存地址，切分成页号和偏移量；
- 根据页号，从页表里面，查询对应的物理页号；
- 直接拿物理页号，加上前面的偏移量，就得到了物理内存地址。



# 0x04 改进

前面说的简单内存分页有空间上的致命缺陷：

    因为操作系统是可以同时运行非常多的进程的，这就意味着页表会非常的庞大。

    在 32 位的环境下，虚拟地址空间共有 4GB，假设一个页的大小是 4KB（2^12），那么就需要大约 100 万 （2^20 = 4 * 1024 * 1024 / 4） 个页，假设每个「页表项」需要 4 个字节大小来存储，那么整个 4GB 空间的映射就需要有 4MB 的内存来存储页表。

    这 4MB 大小的页表，看起来也不是很大。但是要知道每个进程都是有自己的虚拟地址空间的，也就说都有自己的页表。

    那么，100 个进程的话，就需要 400MB 的内存来存储页表，这是非常大的内存了，更别说 64 位的环境了。

所以引入 多级页表 以节省空间。

我们把 100 万个「页表项」的单级页表再分页，将页表（一级页表）分为 1024 个页表（二级页表），每个表（二级页表）中包含 1024 个「页表项」，形成二级分页。

![1](../../pic/linux/memory/m5.png)


**你可能会问，分了二级表，映射 4GB 地址空间就需要 4KB（一级页表，1024 * 4字节）+ 4MB（二级页表 1024 * 1024 * 4字节）的内存，这样占用空间不是更大了吗？**

    如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表。做个简单的计算，假设只有 20% 的一级页表项被用到了，那么页表占用的内存空间就只有 4KB（一级页表） + 20% * 4MB（二级页表）= 0.804MB，这对比单级页表的 4MB 是不是一个巨大的节约？

**那最开始的单页表不也可以这样吗，需要的时候再创建，何必还要多级页表？**

    问的很好，证明在瞎鸡儿想，完全不是一回事。听我说，抛开页表里面的内容（到目前为止，我也不知道里面是啥，以及咋填内容进去的），想象一下：

        - 在单页表机制中，A 进程创建了，你是不是要给它腾出 4M 内存来放页表，先别管里面内容有没有，准不准，反正进程创建了，你得给它 4M 内存，咋用是它的事，你不能先给 1k ，然后发现不够了再加，不是这么回事，你仔细想想。

        - 在多级页表下，A 进程创建了，我只需要给 4k 内存就行，剩下的，用到了再说。


还是没理解节省在哪的话，可以看下面的图：
- 单页表。0、1、1024 填了有效数据，其余的不填也占地方。
- 多级页表。1、2、1024 填了有效数据，其余的不填（一级页表）也一样占地方，但是占的少。而没填的，对应的二级我就是可以不创建。
![1](../../pic/linux/memory/m6.png)
![1](../../pic/linux/memory/m7.png)

# 0x05 再改进

使用多级页表的方式对于减少页表自身占用的内存空间确实是非常有效的。然而，为此付出的代价就是增加了地址转换过程中对内存的访问次数，进而增加了转换时间。目前有两个优化：

- 使用大页（large page）   
- 使用paging structure caches   
    就是在多级页表查找的时候也进行中间结果缓存，加速后续的查找。

## large/huge page

    之前说的 page 一直是 4k ，可以将 page 变为 2M 甚至 1G 。page 变大了，所需要的索引就少了，访问速度也就快了。

> 大多数操作系统采用了分段或分页的方式进行管理。分段是粗粒度的管理方式，而分页则是细粒度管理方式，分页方式可以避免内存空间的浪费。相应地，也就存在内存的物理地址与虚拟地址的概念。

> 通过内存分段、内存分页这两种方式，CPU必须把虚拟地址转换程物理内存地址才能真正访问内存。为了提高这个转换效率，CPU会缓存最近的虚拟内存地址和物理内存地址的映射关系，并保存在一个由 CPU 维护的映射表中。为了尽量提高内存的访问速度，需要在映射表中保存尽量多的映射关系。

> Linux的内存管理采取的是分页存取机制，为了保证物理内存能得到充分的利用，内核会按照 LRU 算法在适当的时候将物理内存中不经常使用的内存页自动交换出去，而保留经常使用的信息。通常情况下，Linux默认情况下每页是4K，这就意味着如果物理内存很大，则映射表的条目将会非常多，会影响 CPU 的检索效率。因为内存大小是固定的，为了减少映射表的条目，可采取的办法只有增加页的尺寸。因此 Hugepage 便因此而来。也就是打破传统的小页面的内存管理方式，使用大页面 2M , 4M 等。如此一来映射条目则明显减少。 TLB 缓存命中率将大大提高。

缺点：
- 由于各种内存操作基本都要求按照 page 对齐，当 page 变大的时候，浪费也就增多了。
- 系统运行一段时间后，会很难再也大块的连续物理内存，这时分配 large page 将会变的很困难，所以通常需要在系统初始化的时候就划分出一段物理内存给 large page 用，这样就减少了一些灵活性。
- 动态 large page(THP) 在换出到外部的 flash/disk 和从 flash/disk 换入物理内存的过程会比 normal size 的 page 带来更大的开销。

## transparent huge page

    在程序需要 huge page 的时候，可通过 内存规整(memory compaction) 操作移动页面，以形成一个 huge page ，因为该过程不会被应用感知到，所以被称为 transparent 。

[memory compaction 介绍](https://tinylab.org/lwn-368869/)