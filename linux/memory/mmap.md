# 0x00、导读

> 使用 mmap 系统调用可以将用户空间的虚拟内存地址与文件进行映射，对映射后的虚拟内存地址进行读写操作就如同对文件进行读写操作一样。

随便一搜，到处都是类似上面的话，我不懂：
1. 虚拟内存地址与文件映射，是虚拟内存地址与磁盘映射吗？这也能映射？！
2. 如果上面说的映射是指把文件读入了内存，那我用 read 和 write 不行吗？

# 0x01、简介

把一段 memory 映射到其它 memory 空间的过程。

    每个进程对虚拟内存都是通过分区域管理的，在虚拟内存分配时，为不同的用途划分不同的虚拟内存区域，这些虚拟内存区域在分配之初并没有为之分配对应的物理内存，而只是分配和设置了管理结构，当进程使用到某个区域的内存，而其又没有对应的物理内存时，系统产生缺页异常，在缺页异常中，系统根据这块内存对应的虚拟内存管理结构为之分配物理内存，在必要情况下（如 mmap ）加载数据到这块物理内存，建立虚拟内存到物理内存的对应关系，然后进程可以继续访问刚才的虚拟内存。

mmap 的实现也是基于上述原理：
- 在使用  mmap 映射某个文件（或者文件的一部分）到进程的地址空间时，并没有加载文件的数据，而只是在进程的虚拟地址空间划分出一块区域，标记这块区域用于映射到文件的数据区域， mmap 的操作就完成了。

- 当进程试图读或者写文件映射区域时，如果没有对应的物理页面，系统发生缺页异常并进入缺页异常处理程序，缺页异常处理程序根据该区域内存的类型使用不同的策略解决缺页。对于使用mmap映射文件的虚拟内存区域，处理程序首先找到相关的文件的管理数据结构，确定所需页面对应的文件偏移，此时需要从文件中把对应数据加载到 page_cache 中。
    - 与read系统调用流程不同的是，在加载的过程中如果虚拟内存区域管理结构设置了 VM_RAND_READ 标志，系统只是把所需的页面数据加载，如果设置了 VM_SEQ_READ 标志，系统会进行和 read 系统调用相同预读过程，至此应用程序所需的页面已经在 page cache 中了，系统调整页表把物理页面对应到应用程序的地址空间。mmap对缺页的处理没有读和写的区别，无论是读还是写造成的缺页异常都要执行上述过程。

- 使用 mmap 读写文件需要注意的问题：
    - 当读写映射的内存区域的物理页面不存在时，发生缺页异常时系统才能进入内核态，如果物理页面存在，应用程序在用户态直接操作内存，不会进入内核态。
    - 调用 read/write 系统调用时，系统对涉及到的页面都调用了 mark_page_accessed 函数， mark_page_accessed 可以标记物理页面的活动状态，活动的页面就不容易被回收，而使用 mmap 读文件不产生缺页异常时不能进入内核态，就无法标记页面的活动状态，这样页面就容易被系统回收（进入缺页异常处理时也只是对新分配所缺页面调用了 mark_page_accessed ）。
    - 在写该内存区域时，如果不进入内核态也无法标记所写的物理页面为 dirty （只用把页表项的 dirty bit 置位），得使用 msync ，见后面。

文件从磁盘载入到内核空间的 page cache ，你可以直接操作了，而不用从 page cache 到用户 memory .

```c
/*
 * addr：指定映射的虚拟内存地址，可以设置为 NULL，让 Linux 内核自动选择合适的虚拟内存地址。
 * length：映射的长度。
 * prot：映射内存的保护模式，可选值如下：
 *     PROT_EXEC：可以被执行。
 *     PROT_READ：可以被读取。
 *     PROT_WRITE：可以被写入。
 *     PROT_NONE：不可访问。
 * flags：指定映射的类型，常用的可选值如下：
 *     MAP_FIXED：使用指定的起始虚拟内存地址进行映射。
 *     MAP_SHARED：与其它所有映射到这个文件的进程共享映射空间（可实现共享内存）。
 *     MAP_PRIVATE：建立一个写时复制（Copy on Write）的私有映射空间。
 *     MAP_LOCKED：锁定映射区的页面，从而防止页面被交换出内存。
 *     ...
 * fd：进行映射的文件句柄。
 * offset：文件偏移量（从文件的何处开始映射）。
*/
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
```

mmap 一个块设备文件（例如 /dev/sda ），就相当于把整块磁盘给 mmap 了。这个 mmap 跟磁盘上的具体文件系统无关（所谓绕过文件系统），而是把磁盘作为一个超级大的、数据块都是连续的文件给 mmap 进虚拟内存了。  
mmap 磁盘块设备上的一个普通文件，是跟磁盘上的文件系统息息相关的——这个 mmap 操作本身就是在这个文件系统提供的，因为 mmap 普通文件的数据块在磁盘上不一定是连续的，需要文件系统给出了索引数据块的方法。

# 0x02、分类

1. 共享文件映射

    修改对所有进程可见，也就是说，如果进程 A 修改了其中某个 page 上的数据，进程 B 之后读取这个 page 得到的就是修改后的内容。有共享就有竞态 (race condition) ， mmap 本身并没有提供互斥机制，需要调用者在使用的过程中自己加锁。

2. 私有文件映射

    进程 A 的修改对进程 B 是不可见的，主要利用的是 Copy On Write (COW) 机制。

    当进程 A 试图修改某个 page 上的数据时，内核会将这个 page 的内容拷贝一份，之后 A 的写操作实际是在这个拷贝的 page 上进行的（进程 A 中对应这个 page 的页表项也需要被修改，以指向新拷贝的 page ），这样进程 B 看到的这个 page 还是原来未经改动的。

    这种修改只会存在于内存中，不会同步到外部的磁盘文件上（事实上也没法同步，因为不同进程所做的修改是不同的）。
    
    私有文件映射最典型的应用就是进程对动态链接库（比如 libc.so ）的使用。

3. 共享匿名映射

    一个典型应用是作为进程间通信机制的 POSIX 共享内存。在 Linux 中， POSIX 共享内存是通过挂载在 /dev/shm 下的 tmpfs 内存文件系统实现的，创建的每一个共享内存都对应 tmpfs 中的一个文件，因此 POSIX 共享内存也可视为共享文件映射。

4. 私有匿名映射

    可以用来实现 glibc 中的 malloc() 。
    > 传统的 malloc() 实现靠的是 brk ，通常 brk 用于分配小块内存， mmap 则用于分配大块内存，这个分界的阈值默认是 128KB （可通过 mallopt 函数调整）。

    利用写时复制技术，一般在分配大块内存时用代替 malloc() 。

# 0x03、同步 fsync/fdatasync/msync

    一个文件在 page cache 中的内容包括 文件数据 也包括 inode数据 。

三个系统调用都涉及把内存中的 dirty page 同步到的块设备上的文件中去。

- fsync 把两部分的 dirty 数据都会同步。除了使用 fsync 强行同步文件之外，系统也会定期自动同步，即把两种 dirty page 回写到磁盘中。

- fdatasync 只回写文件数据的 dirty page 到磁盘中，不回写文件 inode 相关的 dirty page 。

- 在使用 mmap 映射文件到内存地址，向映射地址写入数据时如果没有缺页，就不会进入内核层，也无法设置写入页的状态为 dirty ，但cpu会自动把 **页表** 的 dirty bit 置位，但是如果不设置 **页** 为 dirty ，其他的同步程序，如 fsync 以及内核的同步线程都无法同步这部分数据。  
msync 的主要作用就是检查一个内存区域的页表，把 dirty bit 置位的页表项对应的页的状态设置为 dirty ，如果 msync 指定了 M_SYNC 参数， msync 还会和 fsync 一样同步数据，如果指定为 M_ASYNC ，则用内核同步线程或其他调用同步数据。   
在 munmap 时，系统会对映射的区域执行类似 msync 的操作，（进程在退出时对映射区域也会自动调用 munmap ），写大量数据不调用 msync 会有丢失数据的风险。