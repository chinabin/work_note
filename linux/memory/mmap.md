# 0x00、导读

> 使用 mmap 系统调用可以将用户空间的虚拟内存地址与文件进行映射，对映射后的虚拟内存地址进行读写操作就如同对文件进行读写操作一样。

随便一搜，到处都是类似上面的话，我不懂：
1. 虚拟内存地址与文件映射，是虚拟内存地址与磁盘映射吗？这也能映射？！
2. 如果上面说的映射是指把文件读入了内存，那我用 read 和 write 不行吗？

# 0x01、简介

mmap 的工作原理，当你发起这个调用的时候，它只是在你的虚拟空间中分配了一段空间，连真实的物理地址都不会分配的，当你访问这段空间的时候会产生 page fault ，这个时候才会分配物理内存，并用文件的内容填充这片内存，然后才返回你进程的上下文，这时你的程序才会感知到这片内存里有数据。

文件从磁盘载入到内核空间的 page cache ，你可以直接操作了，而不用从 page cache 到用户 memory .

mmap() 在数据加载到 page cache 的过程中，会触发大量的 page fault 和建立页表映射的操作，开销并不小。

```c
/*
 * addr：指定映射的虚拟内存地址，可以设置为 NULL，让 Linux 内核自动选择合适的虚拟内存地址。
 * length：映射的长度。
 * prot：映射内存的保护模式，可选值如下：
 *     PROT_EXEC：可以被执行。
 *     PROT_READ：可以被读取。
 *     PROT_WRITE：可以被写入。
 *     PROT_NONE：不可访问。
 * flags：指定映射的类型，常用的可选值如下：
 *     MAP_FIXED：使用指定的起始虚拟内存地址进行映射。
 *     MAP_SHARED：与其它所有映射到这个文件的进程共享映射空间（可实现共享内存）。
 *     MAP_PRIVATE：建立一个写时复制（Copy on Write）的私有映射空间。
 *     MAP_LOCKED：锁定映射区的页面，从而防止页面被交换出内存。
 *     ...
 * fd：进行映射的文件句柄。
 * offset：文件偏移量（从文件的何处开始映射）。
*/
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
```

# 0x02、分类

1. 共享文件映射

    修改对所有进程可见，也就是说，如果进程 A 修改了其中某个 page 上的数据，进程 B 之后读取这个 page 得到的就是修改后的内容。有共享就有竞态 (race condition) ， mmap 本身并没有提供互斥机制，需要调用者在使用的过程中自己加锁。

2. 私有文件映射

    进程 A 的修改对进程 B 是不可见的，主要利用的是 Copy On Write (COW) 机制。

    当进程 A 试图修改某个 page 上的数据时，内核会将这个 page 的内容拷贝一份，之后 A 的写操作实际是在这个拷贝的 page 上进行的（进程 A 中对应这个 page 的页表项也需要被修改，以指向新拷贝的 page ），这样进程 B 看到的这个 page 还是原来未经改动的。

    这种修改只会存在于内存中，不会同步到外部的磁盘文件上（事实上也没法同步，因为不同进程所做的修改是不同的）。
    
    私有文件映射最典型的应用就是进程对动态链接库（比如 libc.so ）的使用。

3. 共享匿名映射

    一个典型应用是作为进程间通信机制的 POSIX 共享内存。在 Linux 中， POSIX 共享内存是通过挂载在 /dev/shm 下的 tmpfs 内存文件系统实现的，创建的每一个共享内存都对应 tmpfs 中的一个文件，因此 POSIX 共享内存也可视为共享文件映射。

4. 私有匿名映射

    可以用来实现 glibc 中的 malloc() 。
    > 传统的 malloc() 实现靠的是 brk ，通常 brk 用于分配小块内存， mmap 则用于分配大块内存，这个分界的阈值默认是 128KB （可通过 mallopt 函数调整）。

    利用写时复制技术，一般在分配大块内存时用代替 malloc() 。