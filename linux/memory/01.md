# 0x00、导读

- 什么是内存地址？   
- 什么是虚拟内存地址？为什么要引入虚拟地址（解决了什么问题）？   
- 虚拟地址带来的好处（除了解决问题之外还有什么额外的好处）？   
- 操作系统提供的实现机制是什么？   


# 0x01、内存地址

## 1. 内存地址

    以英特尔 32 位的 80386 型 CPU 为例，这款 CPU 有 32 个针脚可以传输地址信息。每个针脚对应了一位。如果针脚上是高电压，那么这一位是 1 。如果是低电压，那么这一位是 0 。 32 位的电压高低信息通过地址总线传到内存的 32 个针脚，内存就能把电压高低信息转换成 32 位的二进制数，从而知道 CPU 想要的是哪个位置的数据。用十六进制表示， 32 位地址空间就是从 0x00000000 到 0xFFFFFFFF ，所以 32 位操作系统单个进程最大的内存使用空间一般不大于 4G 。

这就是那串 `0xxxxxxxxxx` 数字的由来。在这种 **内存访问模式** 下，几乎不可能同时运行两个程序，例如 A 刚往 0x10001000 写了数据，B 就覆盖了。
所以引入了 **虚拟地址** 。

# 0x02、 虚拟内存地址

## 1. 什么是虚拟地址

    虚拟地址也是内存地址，例如 0x12345678 ，只是解释这串数字的方式变了，原始时代是拿着这串数字(那时候它是按照物理地址来解释)就能操作内存，现在需要将虚拟地址转成物理地址才能操作内存。就像用美元在中国消费，需要先换成人民币才行。

## 2. 虚拟地址的好处

    1. 在支持多进程的系统中，如果各个进程都使用物理地址，则在加载到同一物理内存空间的时候，可能发生冲突。

    2. 直接使用物理地址，不便于进行进程地址空间的隔离。

    3. 物理内存是有限的，在物理内存整体吃紧的时候，可以让多个进程通过分时复用（你早上 8 点用，我早上 9 点用，分开时间）的方法共享一个物理页面（某个进程需要保存的内容可以暂时 swap 到外部的 disk/flash ）。

# 0x03、 虚拟地址与物理地址的转换

    操作系统会提供某种机制（主要是两种方式：内存分段和内存分页），将不同进程的虚拟地址（每个程序被运行起来后，都将拥有自己的独立虚拟地址空间）和不同内存的物理地址映射起来。

## 3.1 内存分段
不是我们的重点，已经是较老的内容了，参见 [内存分段](./内存分段.md) 。

## 3.2 内存分页

参见 [内存分页](./内存分页.md) 。

## 3.3 逻辑地址、线性地址、虚拟地址

    逻辑地址：就是CPU指令发出的地址。在机器语言指令中，来说明操作数或指令的地址。在x86架构中，每个逻辑地址包括两部分：段（Segment）和偏移量（Offset）。   
    线性地址：也称为虚拟地址。在32位CPU中，它是32位的无符号整型，最大可以达到4G。在x86_64 CPU中目前最大可使用48位地址线，即最大可寻址1TB。 

    逻辑地址经过段式映射（Segmentation Translation）到线性地址。线性地址经过页面映射（Page Translation）后，得到物理地址。

![1](../../pic/linux/memory/m13.png)


# 0x04、 总结

为了在多进程环境下，使得进程之间的内存地址不受影响，相互隔离，于是操作系统就为每个进程独立分配一套虚拟地址空间，每个程序只关心自己的虚拟地址就可以，实际上大家的虚拟地址都是一样的，但分布到物理地址内存是不一样的。作为程序，也不用关心物理地址的事情。

每个进程都有自己的虚拟空间，而物理内存只有一个，所以当启用了大量的进程，物理内存必然会很紧张，于是操作系统会通过内存交换技术，把不常使用的内存暂时存放到硬盘（换出），在需要的时候再装载回物理内存（换入）。

那既然有了虚拟地址空间，那必然要把虚拟地址「映射」到物理地址，这个事情通常由操作系统来维护。

那么对于虚拟地址与物理地址的映射关系，可以有分段和分页的方式，同时两者结合都是可以的。

内存分段是根据程序的逻辑角度，分成了栈段、堆段、数据段、代码段等，这样可以分离出不同属性的段，同时是一块连续的空间。但是每个段的大小都不是统一的，这就会导致外部内存碎片和内存交换效率低的问题。

于是，就出现了内存分页，把虚拟空间和物理空间分成大小固定的页，如在 Linux 系统中，每一页的大小为 4KB。由于分了页后，就不会产生细小的内存碎片，解决了内存分段的外部内存碎片问题。同时在内存交换的时候，写入硬盘也就一个页或几个页，这就大大提高了内存交换的效率。

再来，为了解决简单分页产生的页表过大的问题，就有了多级页表，它解决了空间上的问题，但这就会导致 CPU 在寻址的过程中，需要有很多层表参与，加大了时间上的开销。于是根据程序的局部性原理，在 CPU 芯片中加入了 TLB，负责缓存最近常被访问的页表项，大大提高了地址的转换速度。

Linux 系统主要采用了分页管理，但是由于 Intel 处理器的发展史，Linux 系统无法避免分段管理。于是 Linux 就把所有段的基地址设为 0，也就意味着所有程序的地址空间都是线性地址空间（虚拟地址），相当于屏蔽了 CPU 逻辑地址的概念，所以段只被用于访问控制和内存保护。

另外，Linux 系统中虚拟空间分布可分为用户态和内核态两部分，其中用户态的分布：代码段、全局变量、BSS、函数栈、堆内存、映射区。

最后，说下虚拟内存有什么作用？

- 第一，虚拟内存可以使得进程对运行内存超过物理内存大小，因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域。
- 第二，由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就解决了多进程之间地址冲突的问题。
- 第三，页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统提供了更好的安全性。