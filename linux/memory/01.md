# 0x00、简介

什么是内存地址？   
为什么要引入虚拟地址？   
虚拟地址的好处？   
虚拟地址如何与物理地址转换？   
虚拟地址空间的分布？   


# 0x01、内存地址

## 1. 内存地址

    以英特尔 32 位的 80386 型 CPU 为例，这款 CPU 有 32 个针脚可以传输地址信息。每个针脚对应了一位。如果针脚上是高电压，那么这一位是 1 。如果是低电压，那么这一位是 0 。 32 位的电压高低信息通过地址总线传到内存的 32 个针脚，内存就能把电压高低信息转换成 32 位的二进制数，从而知道 CPU 想要的是哪个位置的数据。用十六进制表示， 32 位地址空间就是从 0x00000000 到 0xFFFFFFFF ，所以 32 位操作系统单个进程最大的内存使用空间一般不大于 4G 。

这种 **内存访问模式** 下，几乎不可能同时运行两个程序，例如 A 刚往 0x100 写了数据，可能 B 就覆盖了。
所以引入了 **虚拟地址** 。

# 0x02、 虚拟内存地址

## 1. 什么是虚拟地址

    虚拟地址也是内存地址，例如 0x12345678 ，操作系统通过某种机制将虚拟地址转换为物理地址。
    每个程序被运行起来后，都将拥有自己的独立虚拟地址空间，虚拟地址空间的大小由 CPU 的位数决定的。比如 32 位的硬件平台决定了虚拟地址空间为 4 GB 大小。

## 2. 虚拟地址的好处

    1. 在支持多进程的系统中，如果各个进程的镜像文件都使用物理地址，则在加载到同一物理内存空间的时候，可能发生冲突。

    2. 直接使用物理地址，不便于进行进程地址空间的隔离。

    3. 物理内存是有限的，在物理内存整体吃紧的时候，可以让多个进程通过分时复用的方法共享一个物理页面（某个进程需要保存的内容可以暂时 swap 到外部的 disk/flash ），这有点类似于多线程分时复用共享 CPU 的方式。

## 3. 虚拟地址与物理地址的转换

    操作系统会提供一种机制（主要是两种方式：内存分段和内存分页），将不同进程的虚拟地址和不同内存的物理地址映射起来。

----
### 3.1 内存分段
不是我们的重点，已经是较老的内容了，参见 [内存分段](./内存分段.md) 。

### 3.2 内存分页

参见 [内存分页](./内存分页.md) 。



前面的内存分段和内存分页都有优缺点，我们其实可以结合一下，形成 段页式内存管理 。

![1](../../pic/linux/memory/m9.png)

段页式内存管理实现的方式：

- 先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制；
- 接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页；

这样，地址结构就由段号、段内页号和页内位移三部分组成。

用于段页式地址变换的数据结构是每一个程序一张段表，每个段又建立一张页表，段表中的地址是页表的起始地址，而页表中的地址则为某页的物理页号。

![1](../../pic/linux/memory/m8.png)

段页式地址变换中要得到物理地址须经过三次内存访问：

- 第一次访问段表，得到页表起始地址；
- 第二次访问页表，得到物理页号；
- 第三次将物理页号与页内位移组合，得到物理地址。

### 2.4 TLB

多级页表虽然解决了空间上的问题，但是虚拟地址到物理地址的转换就多了几道转换的工序，这显然就降低了这俩地址转换的速度，也就是带来了时间上的开销。于是就在 CPU 芯片中，加入了一个专门存放程序最常访问的页表项的 Cache，这个 Cache 就是 TLB（Translation Lookaside Buffer） ，通常称为页表缓存、转址旁路缓存、快表等。

在 CPU 芯片里面，封装了内存管理单元（Memory Management Unit）芯片，它用来完成地址转换和 TLB 的访问与交互。
有了 TLB 后，那么 CPU 在寻址时，会先查 TLB，如果没找到，才会继续查常规的页表。

------------------------------

## 3. Linux 内存布局

由于历史原因，了解一下逻辑地址和线性地址。

![1](../../pic/linux/memory/m13.png)

这主要是上面 Intel 处理器发展历史导致的，因为 Intel X86 CPU 一律对程序中使用的地址先进行段式映射，然后才能进行页式映射。既然 CPU 的硬件结构是这样，Linux 内核也只好服从 Intel 的选择。

    逻辑地址：就是CPU指令发出的地址。在机器语言指令中，来说明操作数或指令的地址。在x86架构中，每个逻辑地址包括两部分：段（Segment）和偏移量（Offset）。   
    线性地址：也称为虚拟地址。在32位CPU中，它是32位的无符号整型，最大可以达到4G。在x86_64 CPU中目前最大可使用48位地址线，即最大可寻址1TB。 

    逻辑地址经过段式映射（Segmentation Translation）到线性地址。线性地址经过页面映射（Page Translation）后，得到物理地址。


Linux 内存主要采用的是页式内存管理，但同时也不可避免地涉及了段机制。

![1](../../pic/linux/memory/m10.png)

注意，64 位系统其实只使用了 48 位地址。

![1](../../pic/linux/memory/m11.png)

用户空间分布的情况，以 32 位系统为例：

![1](../../pic/linux/memory/m12.png)

- 代码段，包括二进制可执行代码；
- 数据段，包括已初始化的静态常量和全局变量；
- BSS 段，包括未初始化的静态变量和全局变量；
- 堆段，包括动态分配的内存，从低地址开始向上增长；
- 文件映射段，包括动态库、共享内存等，从低地址开始向上增长；
- 栈段，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 8 MB。当然系统也提供了参数，以便我们自定义大小；

    有几个注意的地方需要说清楚：
    1. 32位系统用户进程最大可以访问3GB，内核代码可以访问所有物理内存。
    2. x86架构中物理地址空间划分三部分：ZONE_DMA、ZONE_NORMAL和ZONE_HIGHMEM。
        ZONE_DMA            内存开始的16MB(0x100 0000)
        ZONE_NORMAL         16MB~896MB(0x3800 0000)
        ZONE_HIGHMEM        896MB ~ 4G。

        因为内核的虚拟地址空间只有1GB，但它需要访问整个4GB的物理空间，因此从物理地址 0~896MB 的部分（ZONE_DMA+ZONE_NORMAL) ，直接加上 3GB 的偏移（在 Linux 中用 PAGE_OFFSET 表示），就得到了对应的虚拟地址，这种映射方式被称为线性/直接映射 (Direct Map) 。

        而 896M~4GB 的物理地址部分 (ZONE_HIGHMEM) 需要映射到 (3G+896M)~4GB 这 128MB 的虚拟地址空间，显然也按线性映射是不行的。

        采用的是做法是，ZONE_HIGHMEM 中的某段物理内存和这 128M 中的某段虚拟空间建立映射，完成所需操作后，需要断开与这部分虚拟空间的映射关系，以便 ZONE_HIGHMEM 中其他的物理内存可以继续往这个区域映射，即动态映射的方式。

        在64位系统中，内核空间的映射变的简单了，因为这时内核的虚拟地址空间已经足够大了，即便它要访问所有的物理内存，直接映射就是，不再需要 ZONE_HIGHMEM 那种动态映射机制了。

![1](../../pic/linux/memory/Linux-Memory-X86-32.jpg)

在虚拟内存空间的 normal memory 区域，内核使用 kmalloc() 来分配内存， kmalloc() 返回的也是虚拟地址，但是分到的内存在物理地址上是连续的（因为是直接映射，在虚拟地址上自然也是连续的）。

在 VMALLOC_START 和 VMALLOC_END 之间的区域为 vmolloc area ，它和 normal memory 中有 8MB 的间隔。这部分间隔不作任何地址映射，相当于一个空洞，主要用做安全保护，防止不正确的越界内存访问，因为此处没有进行任何形式的映射，如果进入到空洞地带，将会触发处理器产生一个异常。

在 vmolloc area 中使用 vmalloc() 分配内存， vmalloc area 中的地址映射不再是简单的3GB偏移，需要建立虚拟地址和物理页面的映射关系，并添加到内核页表中。并且 vmalloc() 分配的内存只能保证在虚拟地址上连续，不能保证在物理地址上连续。

下面这两句话，多读几遍，记住虚拟地址空间是由用户空间和内核空间组成。   

- Linux内核一般将处理器的虚拟地址空间划分为两个部分。底部比较大的部分用于用户进程，顶部则专用于内核。虽然（在两个用户进程之间的）上下文切换期间会改变下半部分，但虚拟地址空间的内核部分总是保持不变。


- Linux将虚拟地址空间划分为：0~3G为用户空间，3~4G为内核空间

--------------

## 4. 总结

为了在多进程环境下，使得进程之间的内存地址不受影响，相互隔离，于是操作系统就为每个进程独立分配一套虚拟地址空间，每个程序只关心自己的虚拟地址就可以，实际上大家的虚拟地址都是一样的，但分布到物理地址内存是不一样的。作为程序，也不用关心物理地址的事情。

每个进程都有自己的虚拟空间，而物理内存只有一个，所以当启用了大量的进程，物理内存必然会很紧张，于是操作系统会通过内存交换技术，把不常使用的内存暂时存放到硬盘（换出），在需要的时候再装载回物理内存（换入）。

那既然有了虚拟地址空间，那必然要把虚拟地址「映射」到物理地址，这个事情通常由操作系统来维护。

那么对于虚拟地址与物理地址的映射关系，可以有分段和分页的方式，同时两者结合都是可以的。

内存分段是根据程序的逻辑角度，分成了栈段、堆段、数据段、代码段等，这样可以分离出不同属性的段，同时是一块连续的空间。但是每个段的大小都不是统一的，这就会导致外部内存碎片和内存交换效率低的问题。

于是，就出现了内存分页，把虚拟空间和物理空间分成大小固定的页，如在 Linux 系统中，每一页的大小为 4KB。由于分了页后，就不会产生细小的内存碎片，解决了内存分段的外部内存碎片问题。同时在内存交换的时候，写入硬盘也就一个页或几个页，这就大大提高了内存交换的效率。

再来，为了解决简单分页产生的页表过大的问题，就有了多级页表，它解决了空间上的问题，但这就会导致 CPU 在寻址的过程中，需要有很多层表参与，加大了时间上的开销。于是根据程序的局部性原理，在 CPU 芯片中加入了 TLB，负责缓存最近常被访问的页表项，大大提高了地址的转换速度。

Linux 系统主要采用了分页管理，但是由于 Intel 处理器的发展史，Linux 系统无法避免分段管理。于是 Linux 就把所有段的基地址设为 0，也就意味着所有程序的地址空间都是线性地址空间（虚拟地址），相当于屏蔽了 CPU 逻辑地址的概念，所以段只被用于访问控制和内存保护。

另外，Linux 系统中虚拟空间分布可分为用户态和内核态两部分，其中用户态的分布：代码段、全局变量、BSS、函数栈、堆内存、映射区。

最后，说下虚拟内存有什么作用？

- 第一，虚拟内存可以使得进程对运行内存超过物理内存大小，因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域。
- 第二，由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就解决了多进程之间地址冲突的问题。
- 第三，页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统提供了更好的安全性。