# 0x00. 导读


# 0x01. 简介

如何讲好内存这个故事，学习过程中我也迷茫了很久。  

# 0x02. 内存分段和内存分页

`0x0000 0000 0000 0000 ~ 0xFFFF FFFF FFFF FFFF` 这是物理地址组成的地址空间，所有的抽象都是为了更方便使用这段范围里面的地址。

## 2.1 内存地址

    以英特尔 32 位的 80386 型 CPU 为例，这款 CPU 有 32 个针脚可以传输地址信息。每个针脚对应了一位。如果针脚上是高电压，那么这一位是 1 。如果是低电压，那么这一位是 0 。 32 位的电压高低信息通过地址总线传到内存的 32 个针脚，内存就能把电压高低信息转换成 32 位的二进制数，从而知道 CPU 想要的是哪个位置的数据。用十六进制表示， 32 位地址空间就是从 0x00000000 到 0xFFFFFFFF ，所以 32 位操作系统单个进程最大的内存使用空间一般不大于 4G 。

这就是那串 `0xxxxxxxxxx` 数字的由来。

在这种原始的 **内存访问模式** 下，几乎不可能同时运行两个程序，例如 A 刚往 0x10001000 写了数据，B 就覆盖了。并且内核和进程运行在一个空间中，安全性极低。

## 2.2 内存分段

将内存分成一个一个的段，每个段都有各自的范围长度、类型和权限，通过 **逻辑地址** 进行数据/指令访问。提升了进程与进程之间、进程与内核之间的隔离性和安全性。   

参见 [内存分段](./内存分段.md) 。

但是内存分段不够灵活，内存颗粒度太大，使得内存利用率不高，于是产生了内存分页。

## 2.3 内存分页

内存分页模式下将内存分成小颗粒度的页，使得效率、安全性都大大提高。

参见 [内存分页介绍](./内存分页01.md) 、[内存分页优化](./内存分页02.md)。

逻辑地址经过段式映射（Segmentation Translation）到线性地址。线性地址经过页面映射（Page Translation）后，得到物理地址。

![1](../../pic/linux/memory/m13.png)

Linux 系统主要采用了分页管理，但是由于 Intel 处理器的发展史，Linux 系统无法避免分段管理。于是 Linux 就把所有段的基地址设为 0，也就意味着所有程序的地址空间都是线性地址空间（虚拟地址），相当于屏蔽了 CPU 逻辑地址的概念，所以段只被用于访问控制和内存保护。

x86 CPU 采用了 **段页式地址映射模型** 。进程代码中的地址为逻辑地址，经过段页式地址映射后，才真正访问物理内存。

段页式机制如下图:

![1](../../pic/linux/memory/091011_1614_Linux1.png)  

## 2.4 总结

1. 虚拟地址的引入自然带来了新的地址空间，[Linux 内存虚拟和物理地址空间](./memory_system00.md)
2. 虚拟地址最终是需要转换为物理地址的。 为了加速查找，引入 cache( [cache详解](./cache00.md) ) 。


  

## 1.2 内存模型

why:  
从硬件上来说，内存就是一块存储物质，为了便述，想象上面有很多个小孔，可以存放东西。系统启动之后，操作系统自己该如何使用它，又如何管理其它进程使用。

what:  
对于内核来说，会把物理内存切分为均匀小块，每块大小是 **4KB** 。每一个物理的 page frame 建立一个 `struct page` 的数据结构来跟踪每一个物理页面的使用情况：是用于内核的正文段？还是用于进程的页表？是用于各种 file cache 还是处于 free 状态等。

所谓 memory model ，其实就是从 cpu 的角度看，其物理内存的分布情况，在 linux kernel 中，使用什么的方式来管理这些物理内存。

how:  
[内存模型](./memory_system04.md) 

