# 0x00. 导读

内存分段最开始是从 Intel 的 8086 CPU 。
1. 什么是内存分段？内存分段又分为 实模式 和 保护模式 
2. 优缺点。


# 0x01. 简介

# 0x02. 机制解释
物理内存分成一个一个的段，每个段都有段基址和段限长，还有段类型和段权限。
段基址和段限长确定一个段的范围，可以防止内存访问越界。
段与段之间也可以互相访问，但是不能随便访问，有一定的规则限制。

## 1.1 逻辑地址

分段内存模式下的地址称为 **逻辑地址**。

分段机制下的地址由两部分组成：
- 段基址(8086 **实模式**) / 段选择因子(80286 **保护模式**)   
    里面最主要的是可以获得一个基础地址，用来与 段内偏移量 做计算。
- 段内偏移量   
    将段基地址加上段内偏移量得到物理内存地址。

（不要纠结图中的 虚拟地址 ，可以换成 虚假地址 ，并不是后文中的虚拟地址。）
![1](../../pic/linux/memory/m2.png)




# 0x02、分段的优点和缺点

## 2.1 优点
1. 能产生连续的内存空间
2. 进程与进程、进程与内核之间的隔离实现了

## 2.2 缺点

1. 内存碎片 。   

    假如一共 100M 内存: 游戏 30M ，浏览器 40M ，聊天 20M 。现在浏览器关了，剩余 100M - 30M - 20M = 50M ，这个时候想看电影，程序需要 50M ，万一刚刚剩余的 50M 不是连续的，那就没法看电影了。

    解决办法是内存交换。聊天暂时换到硬盘上去，腾出 20M 来，再不够游戏再挪挪屁股。

    这个内存交换空间，在 Linux 系统里，也就是我们常看到的 Swap 空间，这块空间是从硬盘划分出来的，用于内存与硬盘的空间交换。这就引入了第二个问题。

2. 内存交换的效率低。   

    对于多进程的系统来说，用分段的方式，内存碎片是很容易产生的，产生了内存碎片，那不得不重新 Swap 内存区域，这个过程会产生性能瓶颈。

    因为硬盘的访问速度要比内存慢太多了，每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上。

    所以，如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿。
