```bash
$ sudo free -w -k && cat /proc/meminfo
              total        used        free      shared     buffers       cache   available
Mem:       65696924     4510608     2818720     4669880          20    58367576    56161268
Swap:      67108860       15380    67093480
MemTotal:       65696924 kB
MemFree:         2818720 kB
MemAvailable:   56161268 kB
Buffers:              20 kB
Cached:         57200576 kB
SwapCached:         2768 kB
Active:         36134384 kB
Inactive:       24784608 kB
Active(anon):    6309440 kB
Inactive(anon):  2078948 kB
Active(file):   29824944 kB
Inactive(file): 22705660 kB
Unevictable:           0 kB
Mlocked:               0 kB
SwapTotal:      67108860 kB
SwapFree:       67093480 kB
Dirty:                 0 kB
Writeback:             0 kB
AnonPages:       3716560 kB
Mapped:           113508 kB
Shmem:           4669880 kB
Slab:            1167000 kB
SReclaimable:    1078292 kB
SUnreclaim:        88708 kB
KernelStack:        7696 kB
PageTables:        15348 kB
NFS_Unstable:          0 kB
Bounce:                0 kB
WritebackTmp:          0 kB
CommitLimit:    99957320 kB
Committed_AS:    8719072 kB
VmallocTotal:   34359738367 kB
VmallocUsed:      420696 kB
VmallocChunk:   34325397500 kB
HardwareCorrupted:     0 kB
AnonHugePages:         0 kB
HugePages_Total:       0
HugePages_Free:        0
HugePages_Rsvd:        0
HugePages_Surp:        0
Hugepagesize:       2048 kB
DirectMap4k:      264312 kB
DirectMap2M:    22693888 kB
DirectMap1G:    46137344 kB
```

----------

# VSS USS RSS PSS

Linux 使用的是虚拟内存 (virtual memory)，因此要准确的计算一个进程实际使用的物理内存就比较麻烦，如下是在计算内存使用率时比较重要的指标：

VSS(Virtual Set Size): 进程通过 malloc() 或者 mmap() 向内存申请内存之后(这部分内存大小称为 VSS )，内核并不会立刻为其分配实际的物理内存。   
等到进程真正使用到内存时(比如调用了 memset() 函数)，内核才会为这个进程分配物理内存，并建立虚拟地址和物理地址之间的映射。

问题来了，动态链接库本身也是要占据物理内存的，那这部分内存应该算在哪个进程头上呢？

为此就出现了三种不同的计算方法：
1. 一种是只计算进程自身占用的物理内存，完全不包含共享库所占用内存的 **USS** (Unique Set Size) 。
2. 一种是把共享库占用的内存直接加到每个进程头上的 **RSS** (Resident Set Size) 。
3. 最后一种是把一个共享库占用的内存，分摊到使用了这个共享库的各个进程头上，称为 **PSS** (Proportional Set Size) 。   
假如一个 so 大小是 3M ，现在三个进程共用，则一个是 1M ，假如一个进程被 kill 掉了，则一个是 1.5M 。

使用 `ps -e u | head` 可以看到 VSZ(VSS) 和 RSS 。
```bash
$ ps u | head
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
centos     959  0.0  0.0 157192     8 pts/16   Ss+  Feb01   0:13 /usr/bin/zsh -i
centos    1858  0.0  0.0 153700  6696 pts/54   Ss   17:55   0:01 /bin/zsh -i
centos    4320  0.0  0.0 151040  5808 pts/35   Ss+  Feb18   0:00 /bin/zsh -i
centos    4509  0.0  0.0 151040  5808 pts/52   Ss+  Feb18   0:00 /bin/zsh -i
centos    5890  0.0  0.0 153908  6760 pts/53   Ss+  Feb18   0:00 /bin/zsh -i
centos    9705  0.0  0.0 179016   392 pts/7    S+   Jan04   0:02 ssh QMT
centos    9856  0.0  0.0 119720  1532 pts/25   S+   Feb18   0:00 tmux at -t tab
centos   14243  0.0  0.0 160444  2696 pts/11   Ss+  Jan31   0:30 /usr/bin/zsh -i
centos   15025  0.0  0.0 179044  1176 pts/8    S+   Feb15   0:00 ssh HTDG0
```

top，也能显示VSS和RSS的信息，只不过叫法不一样，分别被称为了"VIRT"和"RES"。
```bash
   PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
  5952 centos    20   0  157184   2880   1176 S   6.2  0.0   0:14.10 sshd                                                      
 20295 centos    20   0 2043856   1.1g  18764 S   6.2  7.2  34:05.71 node   
```

-----------------------


## 1. MemTotal
    系统从加电开始到引导完成，firmware/BIOS 要保留一些内存，kernel 本身要占用一些内存，最后剩下可供 kernel 支配的内存就是 MemTotal 。这个值在系统运行期间一般是固定不变的。

## 2.MemFree
    表示系统尚未使用的内存。[ MemTotal - MemFree ]就是已被 “用掉” 的内存。

## 3. MemAvailable
    MemFree 不能代表全部可用的内存，系统中有些内存虽然已被使用但是可以回收的，比如 cache/buffer 、 slab 都有一部分可以回收，所以这部分可回收的内存加上 MemFree 才是系统可用的内存，即 MemAvailable 。MemAvailable 是内核使用特定的算法估算出来的，要注意这是一个估计值，并不精确。

## x. CommitLimit Committed_AS
    Memory Overcommit 的意思是操作系统承诺给进程的内存大小超过了实际可用的内存。一个保守的操作系统不会允许 memory overcommit ，有多少就分配多少，再申请就没有了，这其实有些浪费内存，因为进程实际使用到的内存往往比申请的内存要少，比如某个进程 malloc() 了 200MB 内存，但实际上只用到了 100MB ，按照 UNIX/Linux 的算法，物理内存页的分配发生在使用的瞬间，而不是在申请的瞬间，也就是说未用到的 100MB 内存根本就没有分配，这 100MB 内存就闲置了。
    
    理解 memory overcommit 的关键： commit (或 overcommit )针对的是内存申请，内存申请不等于内存分配，内存只在实际用到的时候才分配。

    Linux是允许memory overcommit的，只要你来申请内存我就给你，寄希望于进程实际上用不到那么多内存，但万一用到那么多了呢？那就会发生类似“银行挤兑”的危机，现金(内存)不足了。Linux设计了一个OOM killer机制(OOM = out-of-memory)来处理这种危机：挑选一个进程出来杀死，以腾出部分内存，如果还不够就继续杀…也可通过设置内核参数 vm.panic_on_oom 使得发生OOM时自动重启系统。

    CommitLimit 就是 overcommit 的阈值，申请的 [内存总数] 超过 CommitLimit 的话就算是 overcommit 。

    Committed_AS 表示所有进程已经申请的内存总大小，（注意是已经申请的，不是已经分配的），如果 Committed_AS 超过 CommitLimit 就表示发生了 overcommit，超出越多表示 overcommit 越严重。Committed_AS 的含义换一种说法就是，如果要绝对保证不发生OOM (out of memory) 需要多少物理内存。