# 0x00. 导读

# 0x01. 简介

静态预测（Static prediction）是最简单的分支预测技术，因为它不依赖于代码执行的动态历史信息。相反，它仅依赖于分支指令自身。最简单的静态分支预测方法就是任选一条分支。

动态预测利用分支指令发生转移的历史来进行预测，并根据实际执行情况动态调整预测位，准确率可达90%，现在几乎所有处理器都采用动态预测。


- 不采取（not taken）跳转，顺序执行后面紧挨JMP的指令；
- 采取（taken）跳转到另一块程序内存去执行那里的指令。

# 0x02. 两位饱和计数器（saturating counter）

在现代处理器中，动态分支预测技术在提升处理器 IPC 方面非常重要。

## 2.1 最简单的方法——直接使用上次分支的结果

```c
for(i = 0;i < 1000;i++)
{
    一些语句
}
```

我们假设第一次结果为不跳转，那么第二次、第三次……第1000次预测为跳转，很明显，在使用该方法时，只有两次预测错误（即第一次和最后一次），因此预测的成功率为998/1000=99.8%。

但假设对于一个分支，其方向变化规律为（T表示跳转，N表示不跳转）：TNTNTNTNTN……，那么将会导致每次预测都失败，其成功率为0%。

由于这种方法的准确度波动过大，难以被接受，因此并没有在现代处理器中被采纳。目前应用最广泛的分支预测方法都是基于两位饱和计数器的方法。

![Alt text](../../../pic/linux/simple_prediction.png)

## 2.2 基于两位饱和计数器的分支预测

两位饱和计数器，顾名思义，用两个比特位来存储预测结果，而这两个比特位分别表示如下四种状态：

- Strongly taken, 11：计数器处于饱和状态，分支指令本次会被预测发生跳转
- Weakly taken, 10：计数器处于不饱和状态，分支指令本次会被预测发生跳转
- Weakly not taken, 01：计数器处于不饱和状态，分支指令本次会被预测不发生跳转
- Strongly not token, 00：计数器处于饱和状态，分支指令本次会被预测不发生跳转

![Alt text](../../../pic/linux/saturating_counter.png)

例如上图最左侧是 `00` ，当处于这个状态的时候，分支结果都是不跳转。这个时候预测错了（给出的结果是不跳转，结果是要跳转），状态变为 `01` ，当处于这个状态的时候，分支结果都是不跳转。这个时候预测错了（给出的结果是不跳转，结果是要跳转），状态变为 `10` ，当处于这个状态的时候，分支结果都是跳转。这个时候预测正确（给出的结果是跳转，结果也是要跳转），状态变为 `11` ，当处于这个状态的时候，分支结果都是跳转。

**当状态机处于饱和状态的时候，只有两次连续的预测失败才会改变预测结果。该状态机的初始状态通常采用 Strongly not taken 或者 Weakly not taken。**

```c
for(i = 0;i < 1000;i++)
{
    一些语句
}
```

可以看到，假设状态机初态是 Weakly not token 时，利用饱和计数器方法，其预测准确率是 99.8%。

这种方式的优点在于，对于偶尔的、瞬间的分支方向变化不敏感（比如只是偶尔出现一次方向的改变，预测值很可能不会改变），不过对于 `T-N-T-N-T-N` 型的分支而言，其还是存在成功率过低（根据初态不同，最差为0%，最好为50%）的问题。

# 0x03. 模式历史表, PHT, Pattern History Table

分支预测都是以 PC 值为基础的，所以正常来说，每个 PC 值都对应一个两位的 饱和计数器 。因此，对于 32 位的 PC 值来说，共需要 2^32 / 2^2 * 2b 大小的存储器来存储这些计数器的值，考虑到并不是所有的指令都是分支指令，通常我们会从 PC 的中部取一段作为两位饱和计数器存储器的地址，该存储器叫做 PHT（Pattern History Table），就像下图一样：

![Alt text](../../../pic/linux/Pattern_History_Table.png)

但是这样做，可能会导致多条分支指令共享一个 PHT 项，这会导致别名问题（两个 k 值相同的分支指令 PC 值寻址到同一个表项），会降低分支预测的准确率。为了解决这个问题，可以采用哈希的方法，对PC值进行哈希处理后再去寻址 PHT。

![Alt text](../../../pic/linux/Pattern_History_Table1.png)

这种分支预测方法很难达到98%以上的正确率，因此现代处理器都不会直接使用这种方法了。

PHT 的作用就是，给定一条跳转指令，hash 出来的值传入 PHT ，得到一个结果，跳转 或者 不跳转。

# 0x04. 基于局部历史的分支预测-又称自适应两级分支预测（Adaptive Two-level Predictor）

考虑上文提到的 `T-N-T-N-T-N` 情况，此时的分支预测准确率为 0，当然这与计数器初始状态相关。但是这个跳转的情况其实是规律的，在这个基础上可以使用基于局部历史的分支预测器。在这个设计中一个关键的部件就是 分支历史寄存器（Branch History Register-BHR）。

BHR 位宽为 n, PHT地址宽度与之对应. 用 BHR 来寻址 PHT

PHT 中实际不是每个表项都是一个饱和计数器, 实际只是存储了一个计数器的值. 每次更新表项需要先读出计数器值, 然后放到统一的饱和计数状态机里获得下一个状态的值再写回.

## 4.1 例子

假设 BHR 位宽为 3, 对应一个 8 个表项的 PHT, 假设分支序列是 T -> T -> NT -> NT -> T -> T -> NT -> NT -> T -> T -> NT -> NT -> T -> T -> NT -> NT ->  ...

BHR 是一个移位寄存器, 每次结果假设是从右边移位进来：

- 那么初始的时候，BHR 的值是 000
- 第一个来的是 T, BHR 的值是 001
- 第二个来的是 T, BHR 的值是 011
- 第三个来的是 NT, BHR 的值是 110
- 第四个来的是 NT, BHR 的值是 100
- 第五个来的是 T, BHR 的值是 001
- 第六个来的是 T, BHR 的值是 011
- 第七个来的是 NT, BHR 的值是 110
- 第八个来的是 NT, BHR 的值是 100
- 第九个来的是 T, BHR 的值是 001
- 第十个来的是 T, BHR 的值是 011
- 第十一个来的是 NT, BHR 的值是 110
- 第十二个来的是 NT, BHR 的值是 100
- 第十三个来的是 T, BHR 的值是 001
- 第十四个来的是 T, BHR 的值是 011
- 第十五个来的是 NT, BHR 的值是 110
- 第十六个来的是 NT, BHR 的值是 100
- ....

PHT 中有 8 个表项，key 分别是 000 001 010 011 100 101 110 111 ，其实用到的就 5 个，000 001 011 110 100 。有 key 就有 value ，value 就是前面的 两位饱和计数器 状态机，假设 8 个 value 初始状态都是 01, Weakly not taken 吧，假定 8 个 value 代号分别是 entry0-7 ，随着时间的推移，每次都会自我学习和纠正，最后稳定：

- 初始的时候，BHR 的值是 000, entry0 = 01, 给出的结果是不跳转，实际下一个来的是跳转，所以 entry0 = 10
- 第一个来的是 T, BHR 的值是 001, entry1 = 01, 给出的结果是不跳转，实际下一个来的是跳转，所以更新 entry1 = 10
- 第二个来的是 T, BHR 的值是 011, entry2 = 01, 给出的结果是不跳转，实际下一个来的是不跳转，所以更新 entry2 = 00
- 第三个来的是 NT, BHR 的值是 110, entry3 = 01, 给出的结果是不跳转，实际下一个来的是不跳转，所以更新 entry3 = 00
- 第四个来的是 NT, BHR 的值是 100, entry4 = 01, 给出的结果是不跳转，实际下一个来的是跳转，所以更新 entry4 = 10
- 第五个来的是 T, BHR 的值是 001, entry1 = 10, 给出的结果是跳转，实际下一个来的是跳转，所以更新 **entry1** = 11
- 第六个来的是 T, BHR 的值是 011, entry2 = 00, 给出的结果是不跳转，实际下一个来的是不跳转，所以 **entry2** = 00, 保持不变
- 第七个来的是 NT, BHR 的值是 110, entry3 = 00, 给出的结果是不跳转，实际下一个来的是不跳转，所以 **entry3** = 00, 保持不变
- 第八个来的是 NT, BHR 的值是 100, entry4 = 10, 给出的结果是跳转，实际下一个来的是跳转，所以更新 **entry4** = 11

- 至此，用到的 entry 都已达到饱和状态，下面继续看看，验证一下。

- 第九个来的是 T, BHR 的值是 001, entry1 = 11, 给出的结果是跳转，实际下一个来的是跳转，所以 entry1 = 11, 保持不变
- 第十个来的是 T, BHR 的值是 011, entry2 = 00, 给出的结果是不跳转，实际下一个来的是不跳转，所以 entry2 = 00, 保持不变
- 第十一个来的是 NT, BHR 的值是 110, entry3 = 00, 给出的结果是不跳转，实际下一个来的是不跳转，所以 entry3 = 00, 保持不变
- 第十二个来的是 NT, BHR 的值是 100, entry4 = 11, 给出的结果是跳转，实际下一个来的是跳转，所以 entry4 = 11, 保持不变
- 第十三个来的是 T, BHR 的值是 001, entry1 = 11, 给出的结果是跳转，实际下一个来的是跳转，所以 entry1 = 11, 保持不变
- 第十四个来的是 T, BHR 的值是 011, entry2 = 00, 给出的结果是不跳转，实际下一个来的是不跳转，所以 entry2 = 00, 保持不变
- 第十五个来的是 NT, BHR 的值是 110, entry3 = 00, 给出的结果是不跳转，实际下一个来的是不跳转，所以 entry3 = 00, 保持不变
- 第十六个来的是 NT, BHR 的值是 100, entry4 = 11, 给出的结果是跳转，实际下一个来的是跳转，所以 entry4 = 11, 保持不变
- ....

上面的例子其实 BHR 位宽为 2 就够了，因为相邻的两位 11 10 00 01 后面跟的值都是不一样的，为了例子容易明白，才用 3 位来举例。

序列中，连续相同的数最多有 p 位，则这个序列的循环周期位 p ，例如序列 "11000_11000_11000..." ，因为有 3 个连续的 0 ，2 个连续的 1 ，所以循环周期是 3 而不是 2 ，更不是 5 。只要 BHR 的宽度 n 大于等于 p ，就可以对该序列进行完美的预测。

## 4.2 例子

假如一个 for 循环的次数为 4 ，那么当被编译为汇编指令后，肯定有一条分支指令，这条分支指令就会有类似 TTTNTTTNTTTN... 的行为，我们用 1110_1110_1110_... 表示，1 表示发生了跳转，0 表示没有发生跳转。这个序列的循环周期是 3 ，我们用一个 4 位宽的 BHR ，那么 PHT 中就会有 16 个表项。

我们会发现，BHR 中会循环出现 1110 1101 1011 0111, 并且 
- 1110 后面一定跟着 1 ，所以 PHT 中 1110 对应的计数器会停在 strongly taken 的饱和状态，也就是 11
- 1101 后面一定跟着 1 ，所以 PHT 中 1101 对应的计数器会停在 strongly taken 的饱和状态，也就是 11
- 1011 后面一定跟着 1 ，所以 PHT 中 1011 对应的计数器会停在 strongly taken 的饱和状态，也就是 11
- 0111 后面一定跟着 0 ，所以 PHT 中 0111 对应的计数器会停在 strongly not taken 的饱和状态，也就是 00

PHT 中只用了 4 个表项，其余的 12 个表项都浪费了。

**注意：目前为止，每个分支指令都有自己的 BHR 和 PHT 。**这样需要非常大的存储空间，是不现实的。

BHR 组合在一起的表称作 分支历史寄存器表（Branch History Register Table, BHRT 或 BHT），实际一般都会将 PC 的哈希值作为 BHT 的索引，通过对 BHR 进行复用从而缩小 BHT 的体积。

PHT 的体积也是一个大问题，在最开始的方法中，每一条指令仅仅对应一个 2bit 饱和计数器，而这里却对应若干个 2bit 饱和计数器，其数量和 BHR 的位宽直接相关，也就是说 PHT 变成了 PHTs ，为了解决这个问题，我们可以让所有的指令共用一个 PHT ，然后将 PC 的值与 BHT 输出的值进行处理（如拼接、XOR、哈希等方法）作为PHT的索引，即可大大缩小PHT的大小。

# 0x05. 基于全局历史的分支预测

```c
if(aa == 2) //b1
{
    aa = 0;
}

if(bb == 2) //b2
{
    bb = 0;
}

if(aa != bb) //b3
{
    一些语句
}
```

可以看到，如果分支b1和b2都执行了，那么分支b3就不会执行，只依靠分支b3的局部历史进行分支预测，是永远不会发现这个规律的，因此需要在预测b3时同时考虑b1与b2的跳转结果，为了实现方法，我们需要一个 全局历史寄存器（Global History Register, GHR），这是一个有限位宽的寄存器，来记录最近若干条分支指令的跳转结果，每当遇到一条跳转指令时，就会将其结果移入 GHR 。

使用GHR最简单的方法，便是采用PHTs，由PC选择具体的PHT，再由GHR的值选择PHT的某一项，但是这存问题：PHT过大，因此我们可以采用和0x03类似的优化方法：只使用一个PHT，并将GHR的值与PC做某种混合处理后再作为PHT的索引，这样便大大减少了PHT使用的存储空间。

我们可以注意到，由于这种方法仅考虑了全局历史，却没有考虑局部历史，因此对于TNTN这种有规律的分支，反而可能会出现预测准确度下降的问题。其本质原因在于有些分支指令适合使用基于全局历史的分支预测方法，而另一些则更适合使用句历史的分支预测方法，这就引出了下面的方法。

# 0x06. 竞争的分支预测

对于基于局部历史的分支预测和基于全局历史的分支预测，两种预测方法都有着自身的局限性，因此可以设计一种自适应的分支预测方法，根据不同的分支指令和执行情况自动地选择这两种分支预测方法，称为竞争的分支预测。