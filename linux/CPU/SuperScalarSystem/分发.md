# 0x00. 导读

# 0x01. 简介

对于超标量处理器来说，乱序执行才是最关键的。流水线的分发阶段就是顺序执行和乱序执行的分界点，指令经过寄存器重命名后就会进入流水线的分发阶段。

# 0x02.

发射队列 (Issue Queue)(out-of-order)，大部分的 功能单元(FU) 都可以按照乱序的方式来执行指令，指令在送到 FU 中被执行之前，先被放到一个缓存中，这个缓存就是 **发射队列**，每个 FU 都对应着一个发射队列（先假设如此），当指令被放到这个缓存中的时候它的操作数可能还没有完全准备好，那么它就在这个缓存中等待，只要一条指令的所有源探作数都准备好了，就可以将其送到 FU 中执行，而不用理会这条指令在程序中原始的顺序，超标量处理器正是依靠这种方式来获得比较高的性能，这需要发射队列可以支持这种乱序发射指令的特性。不仅如此，在一个 4-way 的超标量处理器中，每周期最多可以有四条指令被写到这个缓存中，这需要从其中找出四个空闲的表项(entry)，由于乱序执行的特性，缓存中空闲表项的分布是没有规律的，从其中找出四个空闲的表项并不是一件容易的事情，需要在设计中进行权衡。

发射队列 (Issue Queue)(in-order)，即使在乱序执行的超标量处理器中，仍旧有部分指令是按照程序中指定的顺序来执行的，例如分支指令和 store 指令，这些指令如果按照乱序的方式执行，会带来不菲的硬件消耗，而且在性能上也不会带来本质的提高，因此对这些指令一般采取顺序的方式来执行，容纳这些指令的发射队列本质上就是 FIFO，通过调整写指针就可以从中找到空闲的空间，将重命名之后的指令放到其中，因此完全可以用之前讲过的交叠 (interleaving) 方式来实现这种FIFO。

重排序缓存(ROB)，这个部件可以将乱序执行的指令拉回程序中指定的原始顺序指令经过寄存器重命名之后，按照程序中指定的顺序写到重排序缓存中，同时在重排序缓存中还会记录下指令在执行过程中的一些状态，例如是否产生异常等信息，即使有些指令很早就计算完成了，但是它必须等到重排序缓存中在它前面(也就是比它更旧)的所有指令都离开了(也就是退休)，才会允许这条指令改变处理器的状态(这称为Architecture State)。重排序缓存本质上也是FIFO，通过调整写指针就可以找到空闲的空间，将指令写到其中。

**总结来说，流水线的分发(Dispatch)阶段就是将寄存器重命名之后的指令写到发射队列(Issue Queue)和重排序缓存(ROB)的过程**。

指令到达发射队列之后，就可以按照乱序的方式执行了，通过重排序缓存将这些指令再变回到程序中指定的顺序。分发阶段可以和寄存器重命名阶段放在一个周期内完成，但是当发射队列和重排序缓存的容量比较大时，向它们当中写人东西会变得很慢，这样会严重影响处理器的周期时间，因此很多处理器都会为分发阶段单独使用一个流水段，从功能上来看，分发阶段可以称得上是超标量处理器的流水线中最轻松的一级了。

