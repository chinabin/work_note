# 0x00. 导读

TODO: uOP

# 0x01. 简介

# 0x02.

以 x64 中 Intel CPU 为例，一个 Core 内部的又分划分为 **前端、后端、存访** 等部分。

先说前端，前端主要作用是解码、译码。这是干啥的，要了解这点，要先看看什么是指令。

我们从下面这段程序开始：
```
(gdb) disassemble main
Dump of assembler code for function main:
   0x00000000004004b0 <+0>:     sub    $0x38,%rsp
   0x00000000004004b4 <+4>:     xor    %eax,%eax
   0x00000000004004b6 <+6>:     mov    $0x4006c0,%edi
   0x00000000004004bb <+11>:    mov    %rsp,%rsi
   0x00000000004004be <+14>:    movl   $0x3,0x10(%rsp)
```
这段程序开始自内存地址：0x4004b0 处。使用 x / 命令，查看 0x4004b0 处的内存值：
```

(gdb) x/32x 0x00000000004004b0
0x4004b0 <main>:        0x38ec8348      0xc0bfc031      0x48004006      0x44c7e689
0x4004c0 <main+16>:     0x00031024      0x44c70000      0x00021424      0x44c70000
0x4004d0 <main+32>:     0x33442424      0xc5e81122      0x8bffffff      0x8b102444
0x4004e0 <main+48>:     0xd0392414      0x8b483475      0x0001dd15      0xff708d00
0x4004f0 <main+64>:     0x24548948      0x15b70f18      0x000001d6      0x24548966
0x400500 <main+80>:     0x548d4820      0xc3bf1824      0x31004006      0x243489c0
0x400510 <main+96>:     0xffff5be8      0xc48348ff      0x8b48c338      0x0001b405
0x400520 <main+112>:    0x01728d00      0x24448948      0x05b70f18      0x000001ad
```
第一条指令：`sub $0x38,%rsp`，它对应的就是: `0x38ec8348` 。

因为它占 4 个字节码，从 0x4004b0 到 0x4004b3，这 4 个字节的内存值：0x38ec8348，就是这条 sub 指令的编号（或称编码），和 0x38 这个常量，还有 rsp 寄存器的编号。

gdb 在输出时自动做了大小端转化，这 4 个字节原本应该是 48 83 ec 38。最后的 38，就是常量：0x38，这个 ec，我不确定是不是 rsp 的编号，ec 一个 8 个二进制位，有可能 rsp 编号只占其中几个二进制位。最前面的 48 83，一定是 sub 指令编号的一部分。

好了，上面这一段的目的，是为了让你对 “指令”，有个更深入的认识。对于 rsp 的编号到底是几位、sub 指令编码到底是什么，除非是做指令集相关的，没必要搞那么清楚。

我列举这个是想说明什么呢？这和问题有啥关系吗？

有关系，我问个问题，给你指令的编号（编码）规则、和指令集的各种规则，面对这么长一串数字 ：“0x38ec8348 0xc0bfc031 0x48004006 0x44c7e689 0x00031024 0x44c70000 0x00021424 0x44c70000 。。。”

你要花多少时间，才能从中拆解出一条条的指令呢？

我们已经知道，这一长串数字，前 4 字节是”sub $0x38,%rsp“，接下来两字节是”xor %eax,%eax“，接下来 5 个字节是”mov $0x4006c0,%edi“……。

顶级的 CPU，只用几个时钟周期，就能完成一段 32 字节（甚至 64 字节，更早的 CPU 是 16 字节）的二进值串的解码、译码。

32 字节，称为一个 **代码块** 吧。

解码、译码的第一步，称为 **预解码**，就是在一个代码块中，定界出所有指令和每条指令的长度，比如：

第一条指令，从 0 开始，占 4 字节

第二条指令，从 4 字节开始，占两字节

第三条指令，从 6 字节开始，占 5 字节

……

像 Intel、AMD 这种顶级水平的 CPU，能在一个时钟周期内完成一个 32 字节代码块（甚至 64 字节）的预解码。

特别是 Intel，由于没使用台积电的技术，制程上一直在 10 纳米以上，在相同空间中塞入的基础电子器件就不如低制程的多（也就是集成电路密度低），Intel 仍然可以做到 1 个时钟周期完成预解码。


为了让大家更清楚的了解难度，我们再计算下，以主频 3GHz 的 CPU 为例，1 个纳秒 = 3 个时钟周期，也就是 1 纳秒电平高低变化 3 次。

光速是每秒 30 万公里，光在光纤、电路中传播速度，要打个折扣，据说顶多只有真空光速的三分之一，就算是每秒 10 万公里吧，一个时钟周期，光速能在电路中走多远呢？

你可以计算下，3GHz CPU，一个时钟周期，光，也就是走 33 毫米，不严谨的说，也就从指尖到手腕的距离。

你能感受到时钟周期是多快的单位了吧。

并不是所有 CPU，都能在一个时钟周期中，就能完成预解码。

如果某 CPU 预解码要两个周期，就算在核心数、线程数、主频、缓存大小等指标都相同的情况下，这差距，就体现出来了。而且还是巨大的差距。

这才刚开始啊，CPU 内部的弯弯绕多如牛毛。我尽量多说点。

预解码后，要按每条指令的长度，把二进制串中的指令，都读出来，写入一个缓存，一般称为 **指令队列**。这个过程，就称为 **解码** 吧。

指令队列的长度是不同的，即，这块缓存大小不同。

可千万不要认为 CPU 中的缓存只有 L1、L2、L3 啊，CPU 中有各式各样的缓存。但对于应用层之上的开发者，其实连 L1/2/3 Cache 都不需要了解。

我们说回这个指令队列缓存，它就像一个中转站，预解码后，按起始位置、长度，把一个代码块中所有指令读出来写入这个中转站，再开始译码。

但一个代码块中所有指令，很多时候一个周期完不成译码。

预解码后，提供指令，译码负责把指令翻译为 `uOP`。

我想说的是，预解码、解码，相当于生产者，译码，相当于消费者。很多时候，生产者的产量，大于消费者。所以，指令队列这块缓存就相同重要了，生产者生产出的东西，就往这个中转站一扔，就可以了，生产者可以马上开始生产下一批产品（预解码、解码下一个代码块）。

生产者（预解码、解码）每个时钟周期都可以处理一个代码块（需要两个时钟周期，一个周期预解码，一个周期解码并写入指令队列），但如果” 中转站 “满了，生产者（预解码、解码）就要被迫停下来，这就是 CPU 内的流水线 **STALL**（停顿）。

怎么能让”中转站 “尽量不要满？当然就是扩大它的空间了，但空间大，一个是造价高，成本就上去了。另外，” 中转站“归根到底，也是一块缓存，这缓存大了，延迟就上去了。而且，CPU 就那么大块地方，指令队列占的面积多了，其他组件占的面积就少，如何取舍，这可是考验 CPU 设计者的能力水平。

在主频、缓存大小（问题中的缓存，我估计指的就是 L1/2/3 Cache），等都一样的情况下，预解码电路的设计（如何在尽量短的时间完成尽量长的代码块的预解码）、中转站的设计（大小、全相连还是怎么个相连、……），这都对 CPU 性能有很大的影响。

我写这么多，还只是个开头。一条 x64 复杂指令集的指令，还没被翻译成 uOP，微码。
后面还有译码，译码后的 uOP 也要写入缓存，译码的结果（翻译出的 uOP），还要额外的写入另一块缓存，uOP Cache（Intel 也叫 DSB 等名称），还有一个叫 LCD（循环流检测的）的，也和 uOP 有关。

之后，uOP 要经历寄存器重名、写入 ROB、RS，再由 RS 分发到执行单元。如果是访存 uOP，还要写入 Load Buffer（简称 LB）和 Store Buffer（简称 SB），……，太多环节了。

这些都属于微架构，所以，高赞答案说的没错，在主频、缓存大小等都一样的情况下，影响 CPU 性能的，主要是微架构。