# 0x00. 导读

[谁动了我的 CPU 频率 —— CPU 性能之迷 Part 2](https://blog.mygraphql.com/zh/notes/low-tec/kernel/cpu-frequency/)

# 0x01. 简介

# 0x02. 

大多数现代处理器能够在多种不同的 时钟频率和电压 配置下运行，这些对应的 时钟频率和电压 配置通常称为 **Operating Performance Points**, 在 ACPI 术语中，这些配置叫 **p-state** （注意上下文语境）。

在 Linux 中，这种根据需求来调整 CPU 性能的技术称为 **CPU 性能伸缩 (CPU performance scaling)** 或 **CPU 频率伸缩(CPU frequency scaling)**。

## 2.1 Linux CPU 性能伸缩(CPU performance scaling)

Linux 内核通过 CPUFreq(CPU 频率缩放) 子系统支持 CPU 性能缩放，该子系统由三层组成：

1. 缩放核心 (CPUFreq core)  
CPUFreq core 为支持 CPU 性能扩展的所有平台提供通用代码基础设施和用户空间接口。 它定义了其他组件运行的基本框架。

2. 缩放调控器 (scaling governors)  
缩放调控器 (scaling governors) 运行算法来估计所需的 CPU 容量。 通常，每个 scaling governors 都实现一个可以参数化的缩放算法 (scaling algorithm)。

3. 缩放驱动程序 (scaling drivers)  
scaling drivers 与硬件对话。 它们为 scaling governors 提供可用的 p-state 的信息，并通过使用硬件接口来根据 scaling governors 的请求更改 CPU p-state。

了解一下：  
原则上，所有可用的 scaling governors 都可以与任意 scaling drivers 组合使用。然而，这种假设可能不适用于一些硬件特有机制（例如反馈寄存器）的 scaling algorithm ，因为该信息通常来自特定的硬件接口，并且可能不容易在抽象的平台中表示 。 出于这个原因， CPUFreq 允许 scaling drivers 绕过 scaling governors 并实现自己的 scaling algorithm。 intel_pstate 这个 scaling drivers 就是这样做的。

```bash
$ cpupower frequency-info
analyzing CPU 0:
  driver: intel_pstate          <--------------- HERE
  CPUs which run at the same hardware frequency: 0
  CPUs which need to have their frequency coordinated by software: 0
  maximum transition latency:  Cannot determine or is not supported.
  hardware limits: 1.20 GHz - 4.60 GHz
  available cpufreq governors: performance powersave
  current policy: frequency should be within 1.20 GHz and 4.60 GHz.
                  The governor "performance" may decide which speed to use
                  within this range.
  current CPU frequency: Unable to call hardware
  current CPU frequency: 4.60 GHz (asserted by call to kernel)
  boost state support:
    Supported: yes
    Active: yes
```

# 0x03. CPUFreq

为了节省 CPU 的功耗和减少发热，我们有必要根据当前 CPU 的负载状态，动态地提供刚好足够的主频给 CPU 。在 Linux 中，内核的开发者定义了一套框架模型来完成这一目的，它就是 CPUFreq 系统。

我们先从 CPUFreq 提供的 sysfs 接口入手，直观地看看它提供了那些功能。
## 3.1 

```bash
$ cd /sys/devices/system/cpu  
$ ls
cpu0   cpu11  cpu14  cpu17  cpu2   cpu22  cpu25  cpu28  cpu30  cpu33  cpu36  cpu39  cpu6  cpu9     hotplug       kernel_max  offline   power    uevent
cpu1   cpu12  cpu15  cpu18  cpu20  cpu23  cpu26  cpu29  cpu31  cpu34  cpu37  cpu4   cpu7  cpufreq  intel_pstate  microcode   online    present  vulnerabilities
cpu10  cpu13  cpu16  cpu19  cpu21  cpu24  cpu27  cpu3   cpu32  cpu35  cpu38  cpu5   cpu8  cpuidle  isolated      modalias    possible  smt
```

```bash
$ cat online  
0-39  
$ cat offline  
  
$ cat present  
0-39
```

online 代表目前正在工作的 cpu，输出显示编号为 0-39, 表示这 40 个cpu在工作；  
offline 代表目前被关掉的 cpu；  
present 则表示主板上已经安装的 cpu 。如果使用了 intel 的超线程技术，也会显示。

## 3.2

```bash
$ cd /sys/devices/system/cpu/cpu0/cpufreq
$ ls -hlrt

-rw-r--r--. 1 root root 4.0K Jan 16 17:09 scaling_governor
-r--r--r--. 1 root root 4.0K Jan 16 17:09 scaling_available_governors
-rw-r--r--. 1 root root 4.0K Jan 18 16:47 scaling_min_freq
-rw-r--r--. 1 root root 4.0K Jan 18 16:47 scaling_max_freq
-r--r--r--. 1 root root 4.0K Jan 18 16:47 scaling_driver
-r--r--r--. 1 root root 4.0K Jan 18 16:47 scaling_cur_freq
-r--r--r--. 1 root root 4.0K Jan 18 16:47 cpuinfo_transition_latency
-r--r--r--. 1 root root 4.0K Jan 18 16:47 cpuinfo_min_freq
-r--r--r--. 1 root root 4.0K Jan 18 16:47 cpuinfo_max_freq
-r--------. 1 root root 4.0K Jan 18 16:47 cpuinfo_cur_freq
-r--r--r--. 1 root root 4.0K Jan 18 16:47 affected_cpus
-rw-r--r--. 1 root root 4.0K Jan 18 16:47 scaling_setspeed
-r--r--r--. 1 root root 4.0K Jan 18 16:47 related_cpus
```

- cpuinfo_xxx 开头文件代表着cpu硬件上支持的频率
    - cpuinfo_max_freq cpuinfo_min_freq 最大、最小频率
    - cpuinfo_cur_freq 是当前运行的频率
    - cpuinfo_transition_latency 处理器切换频率所需要的时间 (单位: ns)
- scaling_xxx 开头文件代表可以通过 CPUFreq 系统用软件进行调节时所支持的频率
    - scaling_available_governors 可供选择的频率调节策略
        - Performance，最高性能，直接用最高频率，不考虑耗电。
        - Interactive，一开始直接用最高频率，然后根据 CPU 负载慢慢降低。
        - Powersave，省电模式，通常以最低频率运行，系统性能会受影响，一般不会用这个！
        - Userspace，可以在用户空间手动调节频率。
        - Ondemand，定时检查负载，然后根据负载来调节频率。负载低的时候降低 CPU 频率，这样省电，负载高的时候提高 CPU 频率，增加性能.
    - scaling_governor 当前选择的策略
    - scaling_max_freq scaling_min_freq 调节是最大、最小频率 (单位: KHz)
    - scaling_cur_freq 是软件当前指定的频率
    - scaling_driver 调频驱动 （当前intel_pstate）

有些平台，所有 cpu core 的频率和电压时统一控制的，即改变某个 core 上的频率，其它 core 同样受影响。此时只需要实现其中一个 core（通常为 cpu0 ）的 cpufreq 即可，其它 core 的 cpufreq 直接是 cpu0 的符号链接。因此，使用这些API时，随便进入某一个 cpu 下面的 cpufreq 目录即可。

而另一些些平台，不同 core 可以单独控制，这时不同 cpu 目录下的 cpufreq 就不一样了。

到底某一个cpufreq可以控制多少 cpu core 呢？

- affected_cpus 表示该 cpufreq 影响到哪些 cpu core（没有显示处于offline状态的cpu）
- related_cpus 则包括了 online+offline 的所有 core。

如果使用的 governor 是 userspace governor，则可以通过 scaling_setspeed 节点，直接修改 cpu 频率。


我们可以大致梳理出 CPUFreq 系统的构成和工作方式：  

- 首先，CPU的硬件特性决定了这个CPU的最高和最低工作频率，所有的频率调整数值都必须在这个范围内，它们用 cpuinfo_xxx_freq 来表示。

- 然后，我们可以在这个范围内再次定义出一个软件的调节范围，它们用 scaling_xxx_freq 来表示，同时，根据具体的硬件平台的不同，我们还需要提供一个频率表 scaling_available_frequencies ，这个频率表规定了 cpu 可以工作的频率值，当然这些频率值必须要在 cpuinfo_xxx_freq 的范围内。

- 有了这些频率信息，CPUFreq 系统就可以根据当前 cpu 的负载轻重状况，合理地从频率表中选择一个合适的频率供 cpu 使用，已达到节能的目的。

- 至于如何选择频率表中的频率，这个要由不同的 governor(调节器) 来实现，目前的内核版本提供了 5 种 governor 供我们选择。选择好适当的频率以后，具体的频率调节工作就交由 scaling_driver 来完成。

CPUFreq 系统把一些公共的逻辑和接口代码抽象出来，这些代码与平台无关，也与具体的调频策略无关，内核的文档把它称为 CPUFreq Core(/Documents/cpufreq/core.txt) 。
另外一部分，与实际的调频策略相关的部分被称作 cpufreq_policy，cpufreq_policy 又是由频率信息和具体的 governor 组成， governor 才是具体策略的实现者，当然 governor 需要我们提供必要的频率信息， governor 的实现最好能做到平台无关，与平台相关的代码用 cpufreq_driver 表述，它完成实际的频率调节工作。最后，如果其他内核模块需要在频率调节的过程中得到通知消息，则可以通过 cpufreq notifiers 来完成。

## 3.3

一种调频策略的各种限制条件的组合称之为 policy

```bash
$ cd /sys/devices/system/cpu/cpufreq/
$ ls
policy0  policy10  policy12  policy14  policy16  policy18  policy2   policy21  policy23  policy25  policy27  policy29  policy30  policy32  policy34  policy36  policy38  policy4  policy6  policy8
policy1  policy11  policy13  policy15  policy17  policy19  policy20  policy22  policy24  policy26  policy28  policy3   policy31  policy33  policy35  policy37  policy39  policy5  policy7  policy9
```

/sys/devices/system/cpu/cpuY/ 下的 cpufreq 符号链接指向 /sys/devices/system/cpu/cpufreq/policyX

```bash
alfred@bbro-gui:/sys/devices/system/cpu/cpu0$ ls -hlrt
total 0
lrwxrwxrwx 1 root root    0 Jan  3 15:03 cpufreq -> ../cpufreq/policy0
drwxr-xr-x 7 root root    0 Jan  3 15:03 cache
drwxr-xr-x 2 root root    0 Jan  4 16:48 topology
drwxr-xr-x 7 root root    0 Jan 18 22:15 cpuidle
-rw-r--r-- 1 root root 4.0K Jan 18 23:06 uevent
drwxr-xr-x 2 root root    0 Jan 18 23:06 thermal_throttle
lrwxrwxrwx 1 root root    0 Jan 18 23:06 subsystem -> ../../../../bus/cpu
drwxr-xr-x 2 root root    0 Jan 18 23:06 power
lrwxrwxrwx 1 root root    0 Jan 18 23:06 node0 -> ../../node/node0
drwxr-xr-x 2 root root    0 Jan 18 23:06 microcode
drwxr-xr-x 2 root root    0 Jan 18 23:06 hotplug
lrwxrwxrwx 1 root root    0 Jan 18 23:06 firmware_node -> ../../../LNXSYSTM:00/LNXSYBUS:00/ACPI0004:00/LNXCPU:00
lrwxrwxrwx 1 root root    0 Jan 18 23:06 driver -> ../../../../bus/cpu/drivers/processor
-r-------- 1 root root 4.0K Jan 18 23:06 crash_notes_size
-r-------- 1 root root 4.0K Jan 18 23:06 crash_notes

alfred@bbro-gui:/sys/devices/system/cpu/cpu0$ ls -hlrt ../cpufreq/policy0/
total 0
-rw-r--r-- 1 root root 4.0K Dec  9 22:15 scaling_governor
-rw-r--r-- 1 root root 4.0K Jan 18 22:16 scaling_min_freq
-r--r--r-- 1 root root 4.0K Jan 18 22:16 scaling_available_governors
-r--r--r-- 1 root root 4.0K Jan 18 22:16 cpuinfo_max_freq
-r--r--r-- 1 root root 4.0K Jan 18 22:16 related_cpus
-r--r--r-- 1 root root 4.0K Jan 18 22:16 scaling_cur_freq
-rw-r--r-- 1 root root 4.0K Jan 18 22:16 scaling_setspeed
-r--r--r-- 1 root root 4.0K Jan 18 22:16 affected_cpus
-rw-r--r-- 1 root root 4.0K Jan 18 22:16 scaling_max_freq
-r--r--r-- 1 root root 4.0K Jan 18 22:16 cpuinfo_transition_latency
-r--r--r-- 1 root root 4.0K Jan 18 22:16 scaling_driver
-r--r--r-- 1 root root 4.0K Jan 18 22:16 cpuinfo_min_freq
```

policyX 目录每个都包含特定于策略的属性（文件），以控制相应策略对象（即与它们关联的所有 CPU）的 CPUFreq 行为。

其中一些属性是通用的。它们由 CPUFreq core 创建，它们的行为通常不依赖于正在使用的 scaling driver 以及附加到给定策略的 scaling governor。一些 scaling driver 还将驱动程序特定的属性添加到 sysfs 中的策略目录，以控制驱动程序的策略特定行为。