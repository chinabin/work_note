智能指针分为两类：
- 独占型: `unique_ptr` ，一份资源，仅能由一个 `unique_ptr` 对象管理。
- 共享型: `shared_ptr` ，一份资源，可以由多个 `shared_ptr` 对象共同管理，当没有 `shared_ptr` 对象指向这份资源的时候，资源才会被释放，即基于引用技术原理。
- weak_ptr不控制对象的生命周期，但是它观察着shared_ptr管理的对象，有办法知道对象是否还活着。

-----
## unique_ptr

头文件是 `<memory>`

常用:
```c++
std::unique_ptr<int> p;     // 初始化为 nullptr
std::unique_ptr<int> p(std::move(p1));     // p1 变为 nullptr
std::unique_ptr<int> p(new int(10));

p.release();        // 返回指针，释放所有权（没有释放内存）
p.swap(p1);
p.reset(new int), p.reset(p1), p.reset();   // p 反正会释放所有权和内存

if(p)   <==>   if(p.get() != nullptr)
```
作为函数参数和返回值:
```c++
std::unique_ptr<int> f1(std::unique_ptr<int> a) {
    return a;
}


// a 不管是左值引用还是右值引用，都是左值。而移动语义的触发需要右值，所以需要 move(a)
std::unique_ptr<int> f2(std::unique_ptr<int>& a) {
    return std::move(a);
}

std::unique_ptr<int> f3(std::unique_ptr<int>&& a) {
    return std::move(a);
}
```

只有非 `const` 的 `unique_ptr` 才能转移所有权， `const unique_ptr` 会被限定在创建它的范围内。

`unique_ptr` 仅实现了移动构造函数和移动赋值函数。并且有两个版本：
- 管理单个对象（例如以 `new` 分配）
- 管理动态分配的对象数组（例如以 `new[]` 分配）

当下面的情况出现的时候，`unique_ptr` 对象管理的资源，会调用传入的析构器来释放资源（默认的析构器`std::default_delete`）：
- 当前 `std::unique_ptr` 对象被销毁，生命周期结束；
- 重新给当前 `std::unique_ptr` 对象赋值，比如调用 `operator=`、`reset()` 等操作。

`std::default_delete` 实际是个仿函数，并且是个空类:
```c++
template <typename _Tp>
    struct default_delete
    {
        /// @brief 默认构造函数
        constexpr default_delete() noexcept = default;

        /// @brief 复制构造函数
        ///        _Up* 必须能转为 _Tp*，否则无法编译通过
        template <typename _Up, 
                    typename = typename enable_if<is_convertible<_Up*, _Tp*>::value>::type>
        default_delete(const default_delete<_Up>& ) noexcept { }

        /// @brief 释放内存
        void operator()(_Tp *__ptr) const;
    };
```
`is_convertible` 在编译期就能确定结果
```c++
std::is_convertible<float*, double*>::value; // false: float* 不能直接转换为 double*
std::default_delete<double> de(std::default_delete<float>{}); // compile error
```
`operator()` 函数会调用 `delete` 来 析构传入的指针 `__ptr`。因此，可以如下调用:
```c++
int* iptr = new int;
std::default_delete<int>()(iptr); // delete iptr;
```
`_Tp[]` 类型差不多:
```c++
int* iptr = new int[3];
std::default_delete<int[]>()(iptr);
```

```c++
template<typename T, typename ...Args>
std::unique_ptr<T> make_unique( Args&& ...args ) {
  return std::unique_ptr<T>( new T( std::forward<Args>(args)... ) );
}
```

-----

## **copy elision**
`Copy elision` 在 `C++11` 以前是省略 `copy constructor` ，但是 `C++11` 之后，更多地是指省略 `move constructor` （只有 `copy constructor` 而没有 `move constructor` 的时候就是省略 `copy constructor` ）。

`-fno-elide-constructors`

未完待续...


-----

## **shared_ptr**
`shared_ptr` 主要有两个成员变量，一个是指向数据的指针，一个是指向控制块的指针。所以大小是固定的 8 ，即使自定义了删除器，但是 `unique_ptr` 就会增加大小。控制块用来存储这个原生指针的 `shared_ptr` 和 `weak_ptr` 的数量。当 `shared_ptr` 的个数为零的时候，数据就会被删除，当 `shared_ptr` 的个数为零并且弱引用的个数为零的时候，控制块就会被删除。

```c++
auto pointer = std::make_shared<int>(10);

get() 方法来获取原始指针。
reset() 减少一个引用计数。
use_count() 查看一个对象的引用计数。
```


-----

## **weak_ptr**
没有 * 运算符和 -> 运算符，所以不能够对资源进行操作，它的唯一作用就是用于检查 std::shared_ptr 是否存在。
调用 lock() 方法转换成一个 shared_ptr 对象。
```c++
std::weak_ptr<int> w_ptr;
auto ptr = std::make_shared<int>();
w_ptr = ptr;

use_count() 返回共享被管理对象所有权的 shared_ptr 实例数量
expired() 资源未被释放时，会返回 false，否则返回 true。
lock() 返回 std::shared_ptr 或者 nullptr。
reset() 释放被管理对象的所有权。
swap(r) 交换。
```


-----
## **enable_shared_from_this**
```c++
{
    int *p = new int(); 
    shared_ptr<A> ptr1(p);  //调用构造函数
    shared_ptr<A> ptr2(p);  //调用构造函数
    // ptr1 和 ptr2 的引用计数都是 1 ，所以会造成两次析构。
}

{
    int *p = new int(); 
    shared_ptr<A> ptr1(p);      //调用构造函数
    shared_ptr<A> ptr2(ptr1);   //调用拷贝构造函数
    // ptr1 和 ptr2 的引用计数都是 2 ，所以会安全了。
}

shared_from_this() 就是使用了这种技术，维护了一个 weak_ptr ，在调用 shared_from_this 的时候通过拷贝构造函数返回一个 shared_ptr 。
```